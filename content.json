[{"title":"Http报文格式浅析","date":"2019-09-04T12:44:11.000Z","path":"2019/09/04/Http报文格式浅析/","text":"Http报文格式浅析 有了第一篇关于http的介绍，相信大家对http报文已经有了一点点的认识，这一章将接着上一篇，分析一下http报文格式 之所以说是浅析，是因为http报文并没有那么的简单，很多内容不可能在这一篇就介绍完全，比如说是cookie 代理等相关知识，在http报文中都有所体现，所以这一章仅仅只能浅浅地分析一下http中最常见的几种字段内容。 好了，那么废话不多说，直接开始。。。。这一章将先从理论介绍一下http报文格式，再从具体的报文进行分析 Http协议是一个纯文本协议，所谓纯文本协议，我的理解就是所有头部数据都是ASCII码的文本内容，可以很容易的用肉眼识别，不像有些协议是二进制数据格式，很不容易分析。就比如底层的TCP协议，还有我所了解的8583报文以及openflow协议，这些都属于二进制数据协议，不能通过肉眼直接观察就可以大致明白其意思。Http请求报文 我打算先接着下一章 初识Http协议 ，自己实现的python程序收到的浏览器发过来的请求，来分析一下Http报文请求。 Http请求由三大部分组成: 起始行(start line):描述请求的基本信息； 头部字段集合(header):使用key-value形式更详细地说明报文； 消息正文(entity):实际传输数据，它不一定是纯文本(html文件即是纯文本)，可以是图片，视频等二进制数据。前两部分 起始行和头部字段 通常被称为请求头，header，消息正文称为实体，为了与header对应通过也被说成body。Http协议规定报文必须有头部，但可以没有body，在头部字段之后必须有一个空行，也就是”CRLF”，十六进制的 “0D0A”，ASCII码形式的 “\\r\\n”。一图胜千言，相信通过图片能更加直观容易的认识一下报文格式，http报文结构如下图: 好了，通过如上对http报文格式的介绍，我们再从上一章内容浏览器发送的请求入手，来具体分析一下http报文，上一章浏览器发送的报文如下: 12345678910111213**************************************************GET / HTTP/1.1Host: 192.168.112.131:8080Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9If-None-Match: W/&quot;5d46de74-939&quot;If-Modified-Since: Sun, 04 Aug 2019 13:32:36 GMT************************************************** 首先起始行字段，对应的就是我们报文的第一行，”GET / HTTP/1.1”，而后边的以冒号分隔的，就是头部字段描述，key-value形式的，最后是一个空行也就是CRLF。请求行请求行简要的概述了客户端想要如何操作服务端的资源，请求行由三部分构成: 请求方法：是一个动词，如GET/POST，表示对资源的操作； 请求目标：通常是一个URI， 标记了请求方法要操作的资源； 版本号：表示报文使用的HTTP协议版本。这三个部分通常以空格分隔，最后要用CRLF换行表示结束。如上浏览器发送的请求报文， GET代表了请求方法， /就是要操作的资源URI， HTTP/1.1代表了HTTP协议版本号 头部字段头部字段是key-value的形式，key和value之间用”:”分隔，然后以CRLF换行表示字段结束，可以有多个头部字段。比如”Host: 192.168.112.131:8080”，这一行的key就是”Host”,value就是”192.168.112.131:8080”。Http头部字段非常灵活，不仅可以使用标准的Host，Connection等协议规定的头，还可以任意自定义头，这就给http协议带来了无限的扩展可能。使用头部字段需要注意如下几点: 字段名不区分大小写，例如“Host”也可以写成“host”， 但首字母大写的可读性更好； 字段名里不允许出现空格，可以使用连字符”-“,但不能使用下划线”_”。例如，”test-name”是合法的头部字段名，而”test name”和”test_name”就不是正确的字段名； 字段名后必须紧跟着”:”,不能有空格，而”:”后可以有一个或者多个空格； 字段顺序没有任何意义，可以任意排列； 字段原则上不允许重复，除非这个字段本身允许，例如”Set-Cookie”。 请求行和头部字段加起来就构成了完整的Http请求头，如下图: Http响应报文 介绍完了Http请求报文，下面来介绍一下Http应答报文，应答报文是由服务器应答给客户端也就是浏览器的，由于我目前没有完整的web服务器以作测试，我选择使用Nginx来作为web服务器来进行实验，Nginx如何使用我暂且不多做任何解释，仅仅只解释一下简单的配置以及启动命令。Nginx配置1234567891011server &#123; listen 8080; server_name localhost; ... location / &#123; root html; &#125; ... &#125; 这里仅仅只列出了nginx.conf配置最为关键的信息，监听8080端口号，绑定了本地环回地址，location指定了”/“这个URI操作的默认路径为html目录(nginx安装完后自带html目录并且有几个默认的html文件)启动Nginx服务器可以进入到nginx根目录下的sbin目录，里边有一个nginx可执行程序，直接输入nginx运行，没有任何错误信息显示及运行成功。至此，服务端配置完成，接下来我们就来发送请求给nginx服务器，使其回应http应答 为了让大家更清晰的看清楚请求响应这一过程，我这里不选择用浏览器来使用发送http请求，而选择自己组织http请求报文，然后使用telnet这一工具发送并接受应答，这样子可以更加直观看到服务器的响应报文。 首先是组织一下要发送的请求报文这里没有选择上边浏览器发送的报文，是因为浏览器会自带很多功能，例如压缩字段等。。。这样子有对我们观察报文内容会有影响，我组织的报文如下:123456GET /index.html HTTP/1.1Host: 127.0.0.1:8080Connection: keep-aliveUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Language: zh-CN,zh;q=0.9 发送请求报文首先我们使用telnet 127.0.0.1 8080与nginx服务器建立连接，然后把上边报文复制出来，记得带上最后一行的空行，然后再按回车。显示如下:这样子一个完整的请求响应过程就完成了。分析应答报文应答报文截断如下:1234567891011121314151617181920212223242526272829303132333435HTTP/1.1 200 OKServer: nginx/1.14.0Date: Wed, 04 Sep 2019 14:01:29 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Tue, 19 Feb 2019 12:40:41 GMTConnection: keep-aliveETag: &quot;5c6bf949-264&quot;Accept-Ranges: bytes&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt; body &#123; width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 我们可以看到在我们请求报文之后，就是应答报文部分，从”HTTP/1.1 200 OK”这一行开始。其实Http报文的应答报文和请求报文格式很相似，也是起始行，头部字段，正文这一个格式，只不过起始行有个更准确的名字叫做状态行，如下图: 状态行的意思就是服务器响应状态，和请求行一样，同样是有三部分构成: 版本号:表示报文使用的Http协议版本； 状态码：一个三位数，用代码的形式表示处理的结果，比如200是成功，500是服务器内部错误； 原因：作为状态码的补充，是更详细的解释文字，帮助人理解原因。以此来分析状态行，版本号就是”HTTP/1.1”,状态码是”200”, 原因描述是”OK”代表请求成功。 正文介绍 这里直接跳过了响应报文的字段介绍，是因为和请求报文的字段差不多，不过某些字段是属于响应特有的。可以看到这里的Body就是一个html文件，细心的人可能发现了上面的请求报文中GET后面的URI我改成了”/index.html”，以为客户端要请求的服务端资源就是这个URI中的内容，其实不做修改也没事，一般服务器都会默认解释”/“为默认的index.html文件，我这么做只是为了便于理解而已。还记得上面我对nginx服务器配置默认路径为html目录，那么通过此URI就回去html目录下寻找index.html文件，找打的话就把文件内容读出并加在响应头部字段后返回。 试想一下，如果我们使用的不是telnet工具，而是使用浏览器来请求，那么浏览器收到这个应答之后，会是什么效果？其实这也就是我们平时上网，最常见的静态html文件传输，浏览器会把收到的正文内容拿出来并显示内容在界面上。 好了，这样子也算对Http报文格式有了个大概的介绍，下一章将介绍一下Http请求方法","tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"初识Http协议","date":"2019-09-02T13:02:33.000Z","path":"2019/09/02/初识Http协议/","text":"初识Http协议 很早之前，就一直想有着写一系列关于Http协议的博客文章，不过碍于自己学的知识点都非常杂乱，一直没有很系统的把Http给掌握好，很多细节的知识不知道，仅仅只局限于对其粗浅的了解。http是如此，更何况与https呢？虽然也看过一些https相关的东西，当时也觉得自己有所理解，但是并没有动手实践，具体的分析证书认证，交换秘钥，再进行对称加密通信的过程。很快就忘记了。所以现在决定写下一系列的有关http再过渡到https的文章，加上自己曾经理解，学习这一协议的过程，希望自己对于http的理解能更进一步且不那么容易忘记。也希望身边没有入门http协议的朋友能从中了解一点http相关知识。 想要理解网络协议，必须要多少会一点网络编程。这就要说起大家常说的C/S架构, B/S架构,所谓C/S架构就是客户端服务器体系，C代表了Client,S就是Server。而B/S架构，就是浏览器服务器体系,B就是Browser。其实在我看来，浏览器也属于客户端，可能是由于现在的web太火了,而单独列出这一体系。浏览器是一个功能强大的，拥有自己配置界面的配置语言(html css)，和进行数据处理的脚本语言(JavaScript)。浏览器与服务器进行数据交互的过程，底层依赖的就是最基础的网络编程,依赖于Http/Https,还有比较新的websocket协议。 由于自己能力有限，不想去提太多网络编程例如TCP UDP相关的知识，那些要讲的话还得花好多时间，何况我自己还是懂点皮毛而已。怕讲太多会迷路。。。 今天仅仅是简单的介绍一下Http协议是什么，我将从浏览器敲下一个url(网址)然后回车这一过程来分析一下什么是Http,看看它的真实相貌。 首先我们打开一下chrome浏览器,然后输入 https://www.baidu.com ，回车，会发现给我们显示了百度的首页，那么这是一个什么样的过程呢?首先经过的是DNS解析，解析出百度服务器IP地址，有了IP地址，就可以给百度服务器发送请求，百度服务器收到请求之后，再给浏览器响应,浏览器解析百度回应的响应，然后显示百度首页。 我们可以打开浏览器自己尝试一下,F12打开调试器,选中network选项，里边可以找到百度的服务器地址。 上图中看到的 180.101.49.11就是百度服务器地址,443代表了端口号,因为是https协议，所以默认端口号为443，如果是http协议，默认为80。我们可以尝试直接使用IP地址对百度服务器进行请求，https://180.101.49.11 ,发现依旧能显示百度首页，这一过程仅仅略过了DNS解析。 经过上面的分析，我们发现最终请求的其实是IP地址,那么URL这个东西的作用是什么呢？其实很简单，试想一下人们要记住这种毫无规律可言的IP地址是多么困难…所以URL是为了方便人们记忆以及更具有可读性。 既然浏览器输入url回车之后的过程是一个请求与相应的过程,那么我们不妨自己实现一个简单的网络程序，来具体的看一下，浏览器的请求到底是什么样子。 实验环境:我习惯于在linux上用vim写代码，所以准备把服务器demo写在自己的虚拟机ubuntu系统上，当然有局域网实验环境可以，必须保证浏览器所在主机ip和服务器程序所在ip网络是通的。下面我用python实现一个简单的TCP服务器 123456789101112131415161718192021222324252627import socketdef main(): address = (\"\", 8080) # 定义地址元祖,前面为空代表监听本地所有网卡，端口号8080 # 创建socket套接字 sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 绑定套接字 sock.bind(address) # 监听 sock.listen(5) print(\"wait for browser connect...\") conn_sock, peerAddr = sock.accept() # 阻塞等待浏览器连接,conn_sock为与浏览器通信套接字,peerAddr为浏览器地址信息 recv_data = conn_sock.recv(2048) # 接收浏览器发来的数据 print(\"*\"*50) print(recv_data.decode()) # 上下分隔符，为了更清晰观察浏览器发过来的数据 print(\"*\"*50) conn_sock.close() # 关闭套接字 sock.close()if __name__ == \"__main__\": main() 接下来我们可以运行服务程序。显示 “wait for browser connect…”,可以看到服务程序正在等待客户端的连接，我们使用chrome输入 http://192.168.112.131:8080 ,我的ubuntu系统IP地址是192.168.112.131，冒号后边的8080是监听的端口号。然后回车… 可以看到浏览器上显示拒绝了连接请求，那么我们再看服务端程序打印了什么 123456789101112131415wait for browser connect...**************************************************GET / HTTP/1.1Host: 192.168.112.131:8080Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9If-None-Match: W/&quot;5d46de74-939&quot;If-Modified-Since: Sun, 04 Aug 2019 13:32:36 GMT************************************************** 一大通乱七八糟的看不懂的字符串….,其实这就是Http协议报文，因为本章只是初探，暂且啥也不管管。看到了浏览器发来的请求，那么我们回一个响应试试，响应的报文就随便定义一下了。在上面的python代码关闭套接字代码前加上下面代码: 1234http_head = \"HTTP/1.1 200 OK\\r\\n\\r\\n\"body = \"Hello Http\"response = http_head + bodyconn_sock.send(response.encode()) 我们再启动服务器，重复一下上面使用浏览器请求的步骤。神奇的发现浏览器上居然显示了 Hello Http这几个字符串，其实这就是一个简单的浏览器与服务端通过http协议通信的过程，暂且不用来管http协议报文内容，下一节再来分析http报文格式","tags":[{"name":"Http","slug":"Http","permalink":"http://yoursite.com/tags/Http/"}]},{"title":"GDB调试基础实战演示","date":"2019-08-12T14:05:40.000Z","path":"2019/08/12/GDB调试基础实战演示/","text":"时隔半年，终于再次鼓起勇气，开始准备着手记录点什么。从今年三月开始到现在，就一直没有写过任何博客，记录下任何知识。其中有一大部分原因是因为自己克制力太差的原因，即使是这么有兴趣的事情自己还是没能每天持之以恒的坚持。以后会尽量避免，坚持每天都能越来越好一点。自己之所以选择在这么偏僻(没人会来看)的一个地方记录自己所学，而没有选择在CSDN 博客园之类的搜索引擎很容易找到的地方，还是之前原因。自己所学的这些基础，不足挂齿，百度一下千篇一律的文章，我的就不上去献丑了。在这僻静之地留我自己偶尔看看巩固一下即可。。。不碎碎念了，接下来记录一下这两天重新看过的GDB GDB调试因为我个人对GDB所有知识点并不是那种形成体系的熟练，只是遇到问题大概记得用某几个命令来调试而已，所以不能有很好的命令总结之类的描述。只能够写一个例子代码，来进行命令的演示调试。内容大部分完全来自于我对&lt;&lt;Linux网络编程&gt;&gt;这本书的学习。首先写下我们用来做GDB演示的代码，文件名 gdb_test.c :12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int sum(unsigned int n); void usage();typedef struct Tag_IO&#123; int value; int result;&#125;stIO;int main(int argc, char *argv[])&#123; stIO io; int value; if(argc != 2)&#123; usage(); exit(-1); &#125; memset(&amp;io, 0, sizeof(io)); io.value = atoi(argv[1]); io.result = sum(io.value); printf(\"输出: %d\\n\", io.result); return 0;&#125;int sum(unsigned int n)&#123; int i; int result = 0; for(i=0; i&lt;n; ++i)&#123; result +=i; &#125; return result;&#125;void usage()&#123; printf(\"./gdb_test [value]\\n\"); printf(\"Example: ./gdb_test 3\\n\");&#125; 使用命令 gcc -g gdb_test.c -o gdb_test 编译出可执行二进制文件,加上-g参数是为了编译出debug版本，否则不可以使用gdb调试.接下来介绍一些调试命令细节 gdb [可以执行程序名] 进入调试模式 hongning@ubuntu:~/C_Study/day10-GDB$ gdb gdb_testGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.htmlThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type “show copying”and “show warranty” for details.This GDB was configured as “x86_64-linux-gnu”.Type “show configuration” for configuration details.For bug reporting instructions, please see:http://www.gnu.org/software/gdb/bugs/.Find the GDB manual and other documentation resources online at:http://www.gnu.org/software/gdb/documentation/.For help, type “help”.Type “apropos word” to search for commands related to “word”…Reading symbols from gdb_test…done.(gdb) set args 设置命令行参数 (gdb) set args 3 list(可以缩写为l) 打印代码内容,可以通过设置调整显示行数，也可以不断通过list命令往下查看代码 (gdb) l1 #include &lt;stdio.h&gt;2 #include &lt;stdlib.h&gt;3 #include &lt;string.h&gt;45 int sum(unsigned int n);6 void usage();78 typedef struct Tag_IO{9 int value;10 int result; b 设置断点 (gdb) b 32Breakpoint 1 at 0x40076d: file gdb_test.c, line 32. run 运行程序,因为之前设置了断点，和命令行参数.所以暂停在32行 (gdb) runStarting program: /home/hongning/C_Study/day10-GDB/gdb_test 3 Breakpoint 1, sum (n=3) at gdb_test.c:3232 result +=i; display 显示变量，每次运行暂停时都会显示设置的变量值，比print更方便调试 (gdb) display i1: i = 0(gdb) display result2: result = 0(gdb) cContinuing. Breakpoint 1, sum (n=3) at gdb_test.c:3232 result +=i;1: i = 12: result = 0(gdb)Continuing. Breakpoint 1, sum (n=3) at gdb_test.c:3232 result +=i;1: i = 22: result = 1 set 可以修改变量的值,强制修改result的值 (gdb) set result=99(gdb) cContinuing.输出: 101 以上列出了一些简单的命令调试,gdb还可以不带参数执行，然后在内部通过file指定运行程序 hongning@ubuntu:~/C_Study/day10-GDB$ gdbGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.htmlThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type “show copying”and “show warranty” for details.This GDB was configured as “x86_64-linux-gnu”.Type “show configuration” for configuration details.For bug reporting instructions, please see:http://www.gnu.org/software/gdb/bugs/.Find the GDB manual and other documentation resources online at:http://www.gnu.org/software/gdb/documentation/.For help, type “help”.Type “apropos word” to search for commands related to “word”.(gdb) file gdb_testReading symbols from gdb_test…done.(gdb) 然后通过 run命令加参数方式直接运行 (gdb) run 3Starting program: /home/hongning/C_Study/day10-GDB/gdb_test 3输出: 3 参数设置和显示 使用set args命令设置参数，使用show args 显示参数 (gdb) show argsArgument list to give program being debugged when it is started is “3”. 也可以通过 list line1,line2 指定显示行数的代码 (gdb) l 2,302 #include &lt;stdlib.h&gt;3 #include &lt;string.h&gt;45 int sum(unsigned int n);6 void usage();78 typedef struct Tag_IO{9 int value;10 int result;11 }stIO;1213 int main(int argc, char *argv[]){14 stIO io;15 int value;16 if(argc != 2){17 usage();18 exit(-1);19 }20 memset(&amp;io, 0, sizeof(io));2122 io.value = atoi(argv[1]);23 io.result = sum(io.value);24 printf(“输出: %d\\n”, io.result);25 return 0;26 }2728 int sum(unsigned int n){29 int i;30 int result = 0; 打印数据 p 变量名 打印变量的值 (gdb) p result$1 = ‘\\000’ 打印函数调用返回值 (gdb) p sum(3)$1 = 3(gdb) p sum(4)$2 = 6 打印结构体变量的值 (gdb) p io$3 = {value = 3, result = 3} 打印指针变量内部值,在指针变量前加*就可以了，打印变量地址在变量前面加&amp; (gdb) p &amp;io$4 = (stIO *) 0x7fffffffe200 设置断点 break 行号 break 函数名称 break 行号 if条件这里演示一下第三种条件断点情况 (gdb) file gdbReading symbols from gdb…(no debugging symbols found)…done.(gdb) file gdb_testReading symbols from gdb_test…done.(gdb) set args 3(gdb) break 32 if i==2Breakpoint 1 at 0x40076d: file gdb_test.c, line 32.(gdb) runStarting program: /home/hongning/C_Study/day10-GDB/gdb_test 3 Breakpoint 1, sum (n=3) at gdb_test.c:3232 result +=i;(gdb) p i$1 = 2 通过上面例子可以看出i==0 和i==1的时候并没有触发断点 显示断点信息 info break (gdb) info breakNum Type Disp Enb Address What1 breakpoint keep y 0x000000000040076d in sum at gdb_test.c:32 stop only if i==2 breakpoint already hit 1 time Num列是断点编号，可以通过delete b 编号删除断点 (gdb) delete break 1(gdb) info breakNo breakpoints or watchpoints. 还可以通过disable命令禁用断点 (gdb) break 32 if i==2Breakpoint 2 at 0x40076d: file gdb_test.c, line 32.(gdb) info breakNum Type Disp Enb Address What2 breakpoint keep y 0x000000000040076d in sum at gdb_test.c:32 stop only if i==2(gdb) disable break 2(gdb) info breakNum Type Disp Enb Address What2 breakpoint keep n 0x000000000040076d in sum at gdb_test.c:32 stop only if i==2 通过enable命令开启被禁用的断点 (gdb) enable break 2(gdb) info breakNum Type Disp Enb Address What2 breakpoint keep y 0x000000000040076d in sum at gdb_test.c:32 stop only if i==2 以上演示应该注意的是Enb列的值，y代表断点可用，n是不可用 显示变量类型 whatis 命令显示类型 (gdb) whatis iotype = stIO(gdb) whatis argctype = int(gdb) whatis argvtype = char ** ptype 命令还可以显示结构体内部结构 (gdb) ptype iotype = struct Tag_IO { int value; int result;} 单步调试 start单步执行程序 next单步跟踪，也就是一行一行执行程序 step 当遇到函数调用，step命令可以进入调用函数内部 finsh 想退出调用函数内部，使用finish命令就可以了 调用路径 backtrace 显示函数调用路径信息，简写为bt 时间太晚了，后边记录很匆忙，这几条命令我自己用的也比较多，不容易忘记，个人感觉不需要过多演示，下一节准备简单介绍一下多线程调试，多进程调试","tags":[{"name":"GDB","slug":"GDB","permalink":"http://yoursite.com/tags/GDB/"}]},{"title":"Makefile之隐含规则","date":"2019-02-25T13:05:41.000Z","path":"2019/02/25/Makefile之隐含规则/","text":"隐含规则在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们Makefile的兼容性。我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。 使用隐含规则如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：12foo : foo.o bar.occ –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS) 我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：1234foo.o : foo.ccc –c foo.c $(CFLAGS)bar.o : bar.ccc –c bar.c $(CFLAGS) 因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：1foo.o : foo.p 依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。 隐含规则一览这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def,h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。还是先来看一看常用的隐含规则吧。1、编译C程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”2、编译C++程序的隐含规则。“.o” 的目标的依赖目标会自动推导为“.cc”或是“.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”） 3、编译Pascal程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。 4、编译Fortran/Ratfor程序的隐含规则。“.o”的目标的依赖目标会自动推导为“.r”或“.F”或“.f”，并且其生成命令是:“.f” “$(FC) –c $(FFLAGS)”“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)” 5、预处理Fortran/Ratfor程序的隐含规则。“.f”的目标的依赖目标会自动推导为“.r”或“.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)” 6、编译Modula-2程序的隐含规则。“.sym” 的目标的依赖目标会自动推导为“.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。 7、汇编和汇编预处理的隐含规则。“.o” 的目标的依赖目标会自动推导为“.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“.s” 的目标的依赖目标会自动推导为“.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。 8、链接Object文件的隐含规则。“” 目标依赖于“.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：1x : y.o z.o 并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：1234567cc -c x.c -o x.occ -c y.c -o y.occ -c z.c -o z.occ x.o y.o z.o -o xrm -f x.orm -f y.orm -f z.o 如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。9、Yacc C程序时的隐含规则。 “.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料） 10、Lex C程序时的隐含规则。“.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料） 11、Lex Ratfor程序时的隐含规则。“.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。 12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。“.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“.y”和“.l”也是同样的规则。 隐含规则使用的变量在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量对隐含规则的作用。例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量： 关于命令的变量 AR: 函数库打包程序。默认命令是“ar”。 AS:汇编语言编译程序。默认命令是“as”。 CC:C语言编译程序。默认命令是“cc”。 CXX:C++语言编译程序。默认命令是“g++”。 CO:从 RCS文件中扩展文件程序。默认命令是“co”。 CPP:C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。 FC:Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。 GET:从SCCS文件中扩展文件的程序。默认命令是“get”。 LEX:Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。 PC:Pascal语言编译程序。默认命令是“pc”。 YACC:Yacc文法分析器（针对于C程序）。默认命令是“yacc”。 YACCR:Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。 MAKEINFO:转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。 TEX:从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。 TEXI2DVI:从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。 WEAVE:转换Web到TeX的程序。默认命令是“weave”。 CWEAVE:转换C Web 到 TeX的程序。默认命令是“cweave”。 TANGLE:转换Web到Pascal语言的程序。默认命令是“tangle”。 CTANGLE:转换C Web 到 C。默认命令是“ctangle”。 RM:删除文件命令。默认命令是“rm –f”。 关于命令参数的变量下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。 ARFLAGS:函数库打包程序AR命令的参数。默认值是“rv”。 ASFLAGS:汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 CFLAGS:C语言编译器参数。 CXXFLAGS:C++语言编译器参数。 COFLAGS:RCS命令参数。 CPPFLAGS:C预处理器参数。（ C 和 Fortran 编译器也会用到）。 FFLAGS:Fortran语言编译器参数。 GFLAGS:SCCS “get”程序参数。 LDFLAGS:链接器参数。（如：“ld”） LFLAGS:Lex文法分析器参数。 PFLAGS:Pascal语言编译器参数。 RFLAGS:Ratfor 程序的Fortran 编译器参数。 YFLAGS:Yacc文法分析器参数。 隐含规则链有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Makefile之make命令参数","date":"2019-02-24T05:20:58.000Z","path":"2019/02/24/Makefile之make命令参数/","text":"make命令参数介绍下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。 “-b” “-m”：这两个参数的作用是忽略和其他版本make的兼容性 “-B” “–always-make”：认为所有目标都需要更新(重编译) “-C dir” “–directory=dir”:指定makefile的目录。如果有多个”-C”参数，那么后边的路径会以前面的作为相对路径。如:”make -C ~/C_Study/day03-makefile -C 03-make参数”,等价于”make -C ~/C_Study/day03-makefile/03-make参数”。 “–debug=options”：输出make的调试信息。有几个不同的选项参数可以选择，如果没有参数，就输出最简单的调试信息。下面是options的取值:a—也就是all，输出所有调试信息b—也就是basic，只输出简单的调试信息。即输出不需要重编译的目标v—也就是verbose，在b选项的基础之上，输出的信息包含哪个makefile被解析，不需要被重编译的依赖文件(或是依赖目标)等i—也就是implicit，输出所有隐含规则j—也就是jobs，输出执行规则中命令的详细信息，如命令的PID，返回值等m—也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息 “-d”:相当于”–debug=a” “-e” “–environment-overrides”:指明环境变量的值覆盖makefile中定义的变量的值 “-f=file” “–file=file” “–makefile=file”：指定需要执行的makefile “-h” “–help”：显示帮助信息 “-i” “–ignore-errors”:在执行时忽略所有的错误 “-Idir” “–include-dir=dir”:指定make命令搜索路径。可以使用多个”-I”参数指定多个目标 “-j(jobnums)” “–jobs=jobnums”:指同时运行命令的个数，如果没有指定此参数，那么make命令能运行多少就运行多少，如果有一个以上的”-j”参数，那么仅有最后一个才是有效的（注意这个参数在MS-DOS中是无效的） “-k” “–keep-going”：出了错了不会停止运行，如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了 “-l(load)” “–load-average=load” “–max-load=load”:指定make运行命令的负载 “-n” “–just-print” “–dry-run” “–recon”:仅输出执行过程中的命令序列，但并不执行 “-o(file)” “–old-file=file” “–assume-old=file”:不重新生成指定的file，即使这个目标的依赖文件新于它。 “-p” “–print-data-base”:输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。 “q” “–question”:不运行命令，也不输出。仅仅检查所指定的目标是否需要更新，如果是0则说明需要更新，2说明有错误发生 “-r” “–no-builtin-rules”:禁止make使用任何隐含规则 “-R” “–no-builtin-varibles”：禁止make使用任何作用于变量上的隐含规则 “-s” “–slient” “–quiet”:在命令运行时不输出命令的输出 “-S” “–no-keep-going” “–stop”:取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。 “-t” “–touch”:相当于UNIX的touch命令,只是把目标文件的修改日期变成最新的，也就是阻止生成目标的命令运行 “-v” “–version”：输出make程序的版本，版权等关于make的信息 “-w” “–print-directory”:输出运行makefile之前和之后的信息，这个参数对于跟踪嵌套式调用make时很有用。 “–no-print-directory”：禁止“-w”选项。 “-Wfile” “–what-if=file” “–new-file=file” “–assume-file=file”:假定目标file需要更新，如果和”-n”参数配合使用，会输出该目标更新时的运行动作，如果没有”-n”参数，这个命令和UNIX的touch命令一样，使得file修改时间为当前时间 “–warn-undefined-varibles”:只要make发现有未定义的变量，那么就输出警告信息 关于参数”-i”和”-k”的参数区别上面介绍了一大通的命令参数，也没写什么好的例子来做演示，是因为我个人感觉好多参数用的很少。不过学习过程中让我疑惑的就是这两个参数，表面上解释看起来完全一个样子，如果是完全一样为什么要定义两个参数呢，带着疑惑我查了下资料，总算是搞明白了。 “-i”：这个参数是忽略运行过程中任何错误，并继续往下执行，也就是命令级别的忽略错误目标 “-k”：这个参数是当某个目标中出现错误，忽略此目标以及此目标依赖的生成规则，继续往上运行下一个目标详细解释会比较麻烦，这里我把我查询的资料链接附上，有兴趣可以详细看这里。","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Makefile之Makefile运行","date":"2019-02-21T15:14:56.000Z","path":"2019/02/21/Makefile之Makefile运行/","text":"Makefile运行Makefile运行最简单的方法就是输入make命令后执行，这样子make命令会去找寻Makefile文件中第一个目标，然后寻找此目标的依赖文件，找寻依赖文件的依赖文件，然后递归去寻找依赖文件的依赖文件的依赖文件，比对其更新时间，如果对应目标所依赖文件更新时间在目标文件之前，就会执行对应目标之下的命令，以编译出最新的目标文件，这是一个递归的过程，所需细节需要自己慢慢去体会，这里反正我已经理解了，就不做过多解释。嘿嘿！当然有时候make命令不一定要编译文件中第一个目标，可以依据参数来指定某个目标，或者传入对应参数，执行make的不同功能，此章节就是要讲述Makefile运行的细节。 make的退出码make命令执行后有三个退出码： 0：执行成功 1：如果make命令运行出现错误，返回1 2：如果make命令带有-q选项，使得一些目标不需要更新，返回2(后边会详细介绍) 指定MakefileGNU make命令会依次寻找当前目录下边的“GNUmakefile” “makefile” “Makefile”文件，一旦找到，就开始读取这个文件并执行。当然，我们也可以给make命令指定一个特殊名字的文件，让其去执行，想要达到这个目的，就需要用到make的-f参数或者是-=file命令，后边加上文件名，让其去读取运行。如果make命令不只一次使用了-f参数，那么所指定的makefile会被连在一起传递给make命令去执行。 指定目标一般来说，make命令执行的目标就是指定文件中的第一个目标，其他目标都是由第一个目标的依赖文件推导出来的，当然我们也可以给make命令执行目标，只需要在make命令后加上指定目标即可。理论上任何目标都可以被指定成最终目标，除非是“-”打头或者是包含了“=”的目标，前者会被认为是命令行参数，后者会被认为是变量。甚至在make命令执行文件中没有被我们明显指定的目标，也可以成为最终目标，此时就依赖于make命令的隐含规则推导规则，隐含目标同样可以被指定成终极目标。make有一个环境变量叫”MAKECMDGOALS”,这个变量中存放了所指定的终极目标，如果使用make命令时没有指定任何目标，那么这个变量会是空值。示例:123456target: @echo MAKECMDGOALS=$(MAKECMDGOALS).PHONY:appapp: @echo MAKECMDGOALS=$(MAKECMDGOALS) 使用最普通的make命令不带任何参数，会执行第一个目标target下边的命令，结果:1MAKECMDGOALS= 如果我们指定make命令执行指定目标，使用make app命令，结果:1MAKECMDGOALS=app 通常我们书写makefile有些通用的GNU目标规范，使用通用目标规范不仅可以使我们的makefile便于理解，还可以使我们的makefile更加专业，更加规范，下边列出一些GNUmakefile编写的通用目标规范 all:这个伪目标是所有目标的目标，其功能一般是编译所有的目标。 clean:这个伪目标功能是删除所有被make创建的文件。 install：这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。 print：这个伪目标的功能是例出改变过的源文件。 tar：这个伪目标功能是把源程序打包备份。也就是一个tar文件。 dist：这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。 TAGS：这个伪目标功能是更新所有的目标，以备完整地重编译使用。 check和test：这两个伪目标一般用来测试makefile的流程。","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Nginx学习之旅之配置文件介绍","date":"2019-02-19T13:27:14.000Z","path":"2019/02/19/Nginx学习之旅之配置文件介绍/","text":"配置文件语法 配置由指令和指令块构成 每条指令以;分号结尾，指令与参数间以空格符号分隔 指令块以{}大括号将多条指令组织在一起 include语句允许组合多个配置文件以提升可维护性 使用#符号添加注释，提高可读性 使用$符号使用变量 部分指令的参数支持正则表达式Nginx配置文件全局变量arg_PARAMETER #这个变量包含GET请求中，如果有变量PARAMETER时的值。args #这个变量等于请求行中(GET请求)的参数，如：foo=123&amp;bar=blahblah;binary_remote_addr #二进制的客户地址。body_bytes_sent #响应时送出的body字节数数量。即使连接中断，这个数据也是精确的。content_length #请求头中的Content-length字段。content_type #请求头中的Content-Type字段。cookie_COOKIE #cookie COOKIE变量的值document_root #当前请求在root指令中指定的值。document_uri #与uri相同。host #请求主机头字段，否则为服务器名称。hostname #Set to themachine’s hostname as returned by gethostnamehttp_HEADERis_args #如果有args参数，这个变量等于”?”，否则等于””，空值。http_user_agent #客户端agent信息http_cookie #客户端cookie信息limit_rate #这个变量可以限制连接速率。query_string #与args相同。request_body_file #客户端请求主体信息的临时文件名。request_method #客户端请求的动作，通常为GET或POST。remote_addr #客户端的IP地址。remote_port #客户端的端口。remote_user #已经经过Auth Basic Module验证的用户名。request_completion #如果请求结束，设置为OK. 当请求未结束或如果该请求不是请求链串的最后一个时，为空(Empty)。request_method #GET或POSTrequest_filename #当前请求的文件路径，由root或alias指令与URI请求生成。request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。不能修改。scheme #HTTP方法（如http，https）。server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。server_addr #服务器地址，在完成一次系统调用后可以确定这个值。server_name #服务器名称。server_port #请求到达服务器的端口号。nginx.conf配置文件指令介绍 worker_processes:nginx进程数，建议设置为等于CPU总核心数.例子:worker_processes 8; error_log：指定全局错误日志定义类型,[ debug | info | notice | warn | error | crit],例子:error_log /var/log/nginx/error.log info; pid:进程文件,例子:pid /var/run/nginx.pid; worker_rlimit_nofile:一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。例子:worker_rlimit_nofile 65535;指令块 events：工作模式与连接数上限例子: 1234567events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） worker_connections 65535;&#125; http:设定http服务器例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137http&#123; include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream; #默认文件类型 charset utf-8; #默认编码 server_names_hash_bucket_size 128; #服务器名字的hash表大小 client_header_buffer_size 32k; #上传文件大小限制 large_client_header_buffers 4 64k; #设定请求缓 client_max_body_size 8m; #设定请求缓 sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出#文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平 #衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。 tcp_nopush on; #防止网络阻塞 tcp_nodelay on; #防止网络阻塞 keepalive_timeout 120; #长连接超时时间，单位是秒 #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都#能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有#一个warn。 gzip_vary on; #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用 upstream hongningexpro.github.io &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权 #值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; &#125; #虚拟主机的配置 server &#123; listen 80; #监听端口 server_name aa.cn www.aa.cn ; #server_name end #域名可以有多个，用空格隔开 index index.html index.htm index.php; # 设置访问主页 set $subdomain &apos;&apos;; # 绑定目录为二级域名 bbb.aa.com 根目录 /bbb 文件夹 if ( $host ~* &quot;(?:(\\w+\\.)&#123;0,&#125;)(\\b(?!www\\b)\\w+)\\.\\b(?!(com|org|gov|net|cn)\\b)\\w+\\.[a-zA-Z]+&quot; ) &#123; set $subdomain &quot;/$2&quot;; &#125; root /home/wwwroot/aa.cn/web$subdomain;# 访问域名跟目录 include rewrite/dedecms.conf; #rewrite end #载入其他配置文件 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125; #日志格式设定 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /var/log/nginx/test.log access; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; client_max_body_size 10m; #允许客户端请求的最大单文件字节数 client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数， proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时) proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置 proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2） proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传 &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file conf/htpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125;&#125;","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Nginx学习之旅之Nginx编译安装","date":"2019-02-19T12:43:40.000Z","path":"2019/02/19/Nginx学习之旅之Nginx编译安装/","text":"Nginx源码编译安装 首先第一步当然是上官网下载Nginx源码,登录nginx.org,然后点击右下角的download,进入界面后，选择稳定版本(Stable version),选中稳定版本的nginx链接，复制。然后在linux系统上使用wget+链接命令,下载源码。下载完成后，进入下载完成的目录，大致介绍下里边的内容,CHANGES文件里边记录了Nginx版本更新以及所修复的bug等记录，CHANGES.ru文件是俄罗斯语版本的CHANGES文件(因为Nginx是俄罗斯人开发的);contrib目录下vim目录下有有关vim配置有用的文件，可以高亮显示Nginx配置文件的语法关键字等作用,只需要把vim目录下的内容复制到~/.vim/目录下即可生效；configure文件是安装前进行配置的脚本文件，可以指定特定安装目录,指定需要安装的模块等作用。configure的help参数可以列出脚本所支持的参数,–with代表了安装时不会默认安装的模块,可以通过with参数指定某些模块需要编译进去,–without代表了安装时会默认安装的模块，可以通过without参数指定某些模块不需要编译，–prefix参数指定Nginx安装路径；man目录下有对应的nginx使用手册，可以使用man命令+文件名打开 对目录有大致介绍，接下来使用configure脚本进行配置,直接运行即可,它会检查安装Nginx所需要依赖的库文件，如果缺少则需要手动百度安装响应的库 执行完configure脚本后，会在当前目录下生成一个objs目录,cd进入,可以看到里边有一些c语言源文件，和src目录，其中ngx_modules.c指定了编译Nginx时会编译进去的模块 接下来会到我们初始目录，使用make命令，编译,编译完成后，make install命令,Nginx在自己电脑上就安装完成了!","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"Makefile之函数使用","date":"2019-02-18T16:07:15.000Z","path":"2019/02/19/Makefile之函数使用/","text":"Makefile之函数使用在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。 函数的调用语法：函数调用，很像变量的使用，也是以“$”来标识的其语法如下：1$(&lt;function&gt; &lt;arguments&gt; ) 或者1$&#123;&lt;function&gt; &lt;arguments&gt;&#125; 这里，就是函数名，make支持的函数不多。是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。下面将分类介绍各个Makefile支持的函数 字符串处理函数 $(subst from,to,text )名称：字符串替换函数——subst。功能：把字串text中的from字符串替换成to。返回：函数返回被替换过后的字符串。示例：12345var=this is a makefilebar=$(subst t,T,$(var))target: @echo $(bar) 运行结果:1This is a makefile $(patsubst pattern,replacement,text )名称：模式字符串替换函数——patsubst。功能：查找text中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式pattern，如果匹配的话，则以replacement替换。这里，pattern可以包括通配符“%”，表示任意长度的字串。如果replacement中也包含“%”，那么，replacement中的这个“%”将是pattern中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。示例:123456789src1=main.c fun1.c fun2.cobj1=$(patsubst %.c,%.o,$(src1))src2=Patsubst Test!obj2=$(patsubst P%,p%,$(src2))target: @echo obj1=$(obj1) @echo obj2=$(obj2) 结果:12obj1=main.o fun1.o fun2.oobj2=patsubst Test! $(strip string )名称：去空格函数——strip。功能：去掉string字串中开头和结尾的空字符。返回：返回被去掉空格的字符串值。示例：1234567empty=var=$(empty) $(empty) Hello Makefiles_var=$(strip $(var))target2: @echo var:$(var) @echo s_var:$(s_var) 结果:12var: Hello Makefiles_var:Hello Makefile 这上面使用两个空的变量empty定义了一个空格 $(findstring find,in )名称：查找字符串函数——findstring。功能：在字串in中查找find字串。返回：如果找到，那么返回find，否则返回空字符串。示例：123456var1=$(findstring a,a b c)var2=$(findstring a,b c)target: @echo var1=$(var1) @echo var2=$(var2) 结果:12var1=avar2= $(filter pattern…,text )名称：过滤函数——filter。功能：以pattern模式过滤text字符串中的单词，保留符合模式pattern的单词。可以有多个模式。返回：返回符合模式pattern的字串。示例：1234obj=$(filter %.o,main.c main.o base.h wrapper.o wrapper.c wrapper.h)target: @echo $(obj) 结果:1main.o wrapper.o $(filter-out pattern…,text )名称：反过滤函数——filter-out。功能：以pattern模式过滤text字符串中的单词，去除符合模式pattern的单词。可以有多个模式。返回：返回不符合模式pattern的字串。示例：1234src=$(filter %.c,main.c main.o base.h wrapper.o wrapper.c wrapper.h)target: @echo $(src) 结果:1main.c wrapper.c $(sort list )名称：排序函数——sort。功能：给字符串list中的单词排序（升序）。返回：返回排序后的字符串。备注：sort函数会去掉list中相同的单词。示例：1234after_sort_var=$(sort zipper begin cat apple dog boy zipper)target: @echo $(after_sort_var) 结果:1apple begin boy cat dog zipper $(word n,text )名称：取单词函数——word。功能：取字符串text中第n个单词。（从一开始）返回：返回字符串text中第n个单词。如果n比text中的单词数要大，那么返回空字符串。示例:123456choice1=$(word 2, apple boy cat)choice2=$(word 4, apple boy cat)target: @echo choice1=$(choice1) @echo choice2=$(choice2) 结果:12choice1=boychoice2= $(wordlist s,e,text )名称：取单词串函数——wordlist。功能：从字符串text中取从s开始到e的单词串。s和e是一个数字。返回：返回字符串text中从s到e的单词字串。如果s比text中的单词数要大，那么返回空字符串。如果e大于text的单词数，那么返回从s开始，到text结束的单词串。示例：12345678var1=$(wordlist 1,2,i am Makefile)var2=$(wordlist 4,1,i am Makefile)var3=$(wordlist 1,20,i am Makefile)target: @echo $(var1) @echo $(var2) @echo $(var3) 结果:123i ami am Makefile $(words text )名称：单词个数统计函数——words。功能：统计text中字符串中的单词个数。返回：返回text中的单词数。备注：如果我们要取text中最后的一个单词，我们可以这样：$(word $(words text),text )示例:1234count=$(words i am Makefile)target: @echo count=$(count) 结果:1count=3 $(firstword text )名称：首单词函数——firstword。功能：取字符串text中的第一个单词。返回：返回字符串text的第一个单词。备注：这个函数可以用word函数来实现：$(word 1,text )。示例：1234str=$(firstword Hello Makefile)target: @echo str=$(str) 结果：1str=Hello 以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH))) 如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。 文件名处理函数下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。 $(dir names…)名称：取目录函数——dir。功能：从文件名序列names中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列names的目录部分。示例:1234dir=$(dir src/foo.c include/base.h base.c)target: @echo $(dir) 结果:1src/ include/ ./ $(notdir names…)名称：取文件函数——notdir。功能：从文件名序列names中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。返回：返回文件名序列names的非目录部分。示例:1234src=$(notdir src/main.c include/base.h base.c)target: @echo src=$(src) 结果:1src=main.c base.h base.c $(suffix names…)名称：取后缀函数——suffix。功能：从文件名序列names中取出各个文件名的后缀。返回：返回文件名序列names的后缀序列，如果文件没有后缀，则返回空字串。示例:1234suffix=$(suffix src/main.c include/base.h base.c)target: @echo suffix=$(suffix) 结果:1suffix=.c .h .c $(basename names…)名称：取前缀函数——basename。功能：从文件名序列names中取出各个文件名的前缀部分。返回：返回文件名序列names的前缀序列，如果文件没有前缀，则返回空字串。示例:1234basename=$(basename src/main.c include/base.h .S)target: @echo basename=$(basename) 结果：1basename=src/main include/base $(addsuffix suffix,names…)名称：加后缀函数——addsuffix。功能：把后缀suffix加到names中的每个单词后面。返回：返回加过后缀的文件名序列。示例:1234src=$(addsuffix .c,main bar foo)target: @echo src=$(src) 结果:1src=main.c bar.c foo.c $(addprefix prefix,names…)名称：加前缀函数——addprefix。功能：把前缀prefix加到names中的每个单词后面。返回：返回加过前缀的文件名序列。示例:1234src=$(addprefix src/,main.c foo.c bar.c)target: @echo src=$(src) 结果:1src=src/main.c src/foo.c src/bar.c $(join list1,list2)名称：连接函数——join。功能：把list2中的单词对应地加到list1的单词后面。如果list1的单词个数要比list2的多，那么，list1中的多出来的单词将保持原样。如果list2的单词个数要比list1多，那么，list2多出来的单词将被复制到list2中。返回：返回连接过后的字符串。示例:1234str=$(join aaa bbb ccc,111 222 333)target: @echo str=$(str) 结果:1str=aaa111 bbb222 ccc333 foreach 函数 $(foreach var,list,text)介绍:foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。功能:把参数list中的单词逐一取出放到参数var所指定的变量中，然后再执行text所包含的表达式。每一次text会返回一个字符串，循环过程中，text的所返回的每个字符串会以格分隔，最后当整个循环结束时，text所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值注意：foreach中的var参数是一个临时的局部变量，foreach函数执行完后，参数var的变量将不在作用，其作用域只在foreach函数当中。示例:1234res=$(foreach n,main foo bar,$(n).c)target: @echo res=$(res) 结果:1res=main.c foo.c bar.c 在这个示例中，会依次遍历第二参数中的字符串，赋值给n,然后再根据第三参数组合，最后返回遍历完成的结果 if 函数 $(if condition,then-part) 或 $(if condition,then-part,else-part)介绍:if函数很像GNU的make所支持的条件语句——ifeq功能:可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。condition参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，then-part会被计算，否则else-part会被计算返回值:如果condition为真（非空字符串），那个then- part会是整个函数的返回值，如果condition为假（空字符串），那么else-part会是整个函数的返回值，此时如else-part没有被定义，那么，整个函数返回空字串示例:12345flag=res=$(if $(flag),true-part,false-part)target: @echo res=$(res) 结果:1res=false-part call函数 $(call expression,parm1,parm2,parm3…)功能:call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。返回值:当 make执行这个函数时，expression参数中的变量，如$(1)，$(2)，$(3)等，会被参数parm1，parm2，parm3依次取代。而expression的返回值就是 call函数的返回值。示例:12345func=$(1) $(2)res=$(call func,hello,makefile)target: @echo res=$(res) 结果:1res=hello makefile origin函数 $(origin variable)功能:origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的注意:variable是变量的名字，不应该是引用。所以你最好不要在variable中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”返回值: undefined:如果variable从来没有定义过，origin函数返回这个值“undefined” default:如果variable是一个默认的定义，比如“CC”这个变量 environment:如果variable是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开 file:如果variable这个变量被定义在Makefile中 command line:如果variable这个变量是被命令行定义的 override:如果variable是被override指示符重新定义的 automatic:如果variable是一个命令运行中的自动化变量。关于自动化变量将在后面讲述示例:1234567891011121314151617var=Hellooverride val=XXres_undef=$(origin A)res_default=$(origin CC)res_env=$(origin HOME)res_file=$(origin var)res_cmd=$(origin DEF)res_ord=$(origin val )target: @echo res_undef=$(res_undef) @echo res_default=$(res_default) @echo res_env=$(res_env) @echo res_file=$(res_file) @echo res_cmd=$(res_cmd) @echo res_ord=$(res_ord) 此处HOME是linux系统环境变量,使用make DEF=hello命令，传入命令行参数,结果:123456res_undef=undefinedres_default=defaultres_env=environmentres_file=fileres_cmd=command lineres_ord=override shell函数 $(shell cmd args…)介绍:shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回值:cmd命令返回内容注意:这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多示例:1234ls_res=$(shell ls -a)target: @echo ls_res=$(ls_res) 结果:1ls_res=. .. addprefix.mak addsuffix.mak basename.mak call.mak dir.mak foreach.mak if.mak join.mak notdir.mak origin.mak shell.mak suffix.mak Makefile控制函数控制函数不同于上边的函数，顾名思义，控制函数可以控制make的执行make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止 $(error text …)介绍:产生一个致命的错误，text是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的示例:123target: $(error this is an error) @echo after err #因为上边调用了error函数，make执行就退出了，所以这一句不会被执行 结果：1error.mak:2: *** this is an error. Stop. $(warning text …)介绍:这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行示例:123target: $(warning this is an warning) @echo after warning 结果:12warning.mak:2: this is an warningafter warning","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Makefile之条件判断","date":"2019-02-18T14:48:07.000Z","path":"2019/02/18/Makefile之条件判断/","text":"Make之条件判断语句Makefile条件判断即使make能像编程语言一样，使用条件判断类似if这种语句来选择执行的分支 语法规则如下123&lt;conditional-directive&gt;&lt;text-if-true&gt;endif 或者12345&lt;conditional-directive&gt;&lt;text-if-true&gt;else&lt;text-if-false&gt;endif 此处的conditional-directive代表了条件判断语句，下面的text-if-true代表条件成立情况下要执行的分支。条件判断语句有四种,分别是：ifeq,ifneq,ifdef,ifndef ifeq:有两个参数，值相等条件为真 ifneq:值不相等条件为假 ifdef:如果变量定义且不为空条件为真 ifndef:如果变量未定义或者为空则为真很好理解的东西，下边看一个具体的示例:123456789flag=Trueifeq ($(flag),True)var=flag is Trueelsevar=flag is Falseendiftar: @echo $(var) 结果:1flag is True","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Makefile之变量","date":"2019-02-12T15:11:23.000Z","path":"2019/02/12/Makefile之变量/","text":"Makefile变量使用Makefile变量赋值符Makefile变量赋值符类似于编程语言中对变量进行赋值的符号,常见的有 = 号,makefile中我目前所知道的有四种赋值符号,分别如下: =:这是最普通的赋值符号，赋值完成后使用变量会变成替换=之后的内容 := :这种方式定义的变量，前面定义的变量不可以使用后边定义的变量，其实可以防止递归定义变量带来的缺陷，下文会有解释。 ?= :这种方式定义的变量，如果前面已经定义过，那么此条定义语句就没有任何作用，也就是只有首次定义才会有效 += :追加定义变量接下来详细解释下每种定义变量的区别1.最普通的= 定义变量，可以在任何位置定义变量，也就是说不一定要先定义,下面请看一个例子123foo=$(bar)bar=$(ugh)ugh=Huh? 那么最后foo的值就是Huh? ，这也就是=定义变量之前先引用之后定义的变量。缺点:这种方式定义变量有明显的缺陷，就是递归定义，请看如下例子：1CFLAGS=$(CFLAGS) -O 12A=$(B)B=$(A) 这样子就会使得make陷入无限的变量展开过程中去，当然make具备检测这种情况的能力，会报错，为了避免上述情况发生，我们就可以使用”:=”符号定义变量2.上面对”:=”已经有了初步介绍，下边请看详细的例子解释:123x :=fooy :=$(x) barx := later 最后的结果就是 y的值是”foo bar” ，x是”later”12y :=$(x) barx :=later 最后的结果就是 y的值是”bar” ，x是”later”3.接下来说一下追加定义变量符号 “+=”12obj=a.o b.oobj+=c.o 最终obj结果就是”a.o b.o c.o”，其等价于12obj=a.o b.oobj :=$(obj) c.o 如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：12variable := valuevariable += more 等价于12variable := valuevariable := $(variable) more 但如果是这种情况:12variable = valuevariable += more 由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。 变量的高级用法变量值的替换我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。例子:12foo := a.o b.o c.obar := $(foo:.o=.c) 这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。把变量的值再当成变量请看如下例子:1234x=yy=Hellovar=$($(x)) 这样子其实就是个嵌套取变量内容，最终var=Hello,这一点有点类似于C语言中的取地址符号&amp;,当然这也可以使用更多层次 override 指示符使用override指示符定义的变量，可以忽略make命令通过命令行参数传入的变量的值，覆盖命令行参数传值的作用。示例:12345678910VAR=Hello overridetarget: echo $(VAR)``` 使用make VAR=Ignore命令，也就是传值给VAR变量，结果显示如下:```Makefileecho IgnoreIgnore 也就是说命令行参数传递变量方式会覆盖我们内部定义的变量。那么我们使用override关键字定义的变量呢? 123override VAR=Hello overridetarget: echo $(VAR) 同样使用上边的make命令，结果如下: 12echo Hello overrideHello override 定义多行变量定义多行变量一般都是用在多行命令中来,使用define关键字可以定义一个变量的值为多行命令示例:1234567define two_echo echo \"Hello define!\" echo \"Hello end!\"endeftarget: $(two_echo) 结果如下:1234echo &quot;Hello define!&quot;Hello define!echo &quot;Hello end!&quot;Hello end! 目标变量见名思意，目标变量是仅仅只针对于某个目标而定义的变量，特点是不会被全局变量所覆盖示例:123456789target1:var=i am target1var=Hello Target varibletarget1: echo $(var)target2: echo $(var) 如果使用make target1命令，结果显示:12echo i am target1i am target1 如果是make target2命令,结果显示:12echo Hello Target varibleHello Target varible 也就是说目标变量针对于某个目标下面的命令有效 模式变量其实这个和目标变量很类似，目标变量是针对某种目标，模式变量是针对某种模式,比如make支持的%模式，%.o就是所有以.o结尾的文件1%.o:var=hello 那么接下来所有以.o结尾的目标使用的变量var都是hello","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Makefile基础","date":"2019-02-11T15:11:25.000Z","path":"2019/02/11/Makefile基础/","text":"此文记录了我对makefile学习的一点点笔记,这一篇是基础部分。作为一个linux下的c语言程序员,makefile这种基础技能是我不可缺少的能力。 Makefile基础知识Makefile介绍make命令执行时，首先会在当前目录下寻找命名为”Makefile” 或者是 “makefile”的文件(其实还有其他名字，但是我记不住，无所谓的，常见的开发过程中最常见的这两种名字也完全够用了)。如果在当前目录下找到了此文件,则会按照一定规则执行文件中的内容(命令)。 常见的Makefile书写规则形式如下(下述例子中的名字仅以英文意思命名，容易理解，并不代表真正Makefile书写中一定要按照如此名字):12target:prerequisites command target:目标文件，makefile最常见的功能就是编译出可执行程序，target意思为目标，代表了下面的命令要生成的文件名。其实这只是常见的人们的习惯，如果要从Makefile运行原理上来说，完全不必拘泥于这些不成文的规则。target也可以是一个标签，常见的用法有clean标签，用来清理make所产生的文件。 prerequisites:依赖，也就是生成target所要依赖的文件 command：见名知意，命令的意思Makefile工作原理1.make命令会在当前目录下寻找名字为”Makefile”或”makefile”的文件2.如果找到，它会找文件中第一个目标文件(target)3.如果目标文件冒号后边存在依赖文件,它会找目标冒号后边的依赖文件(prerequisites),依赖文件可以是一个或者多个。如果目标文件不存在或者是依赖文件的修改时间要比目标文件新,会执行下边的命令。如果依赖文件的依赖性也存在，则会进入下边去寻找依赖文件的依赖文件,以确保生成最新的依赖文件,makefile的执行就像是一个递归的过程. 以上解释也是仅凭我个人理解所记录，不大好理解。。。。。抱歉！Makefile中使用变量我们为了简化Makefile的书写，在编译大型项目的情况下，通常会有很多个小文件，为了方便我们添加编译文件而无需改动太大，我们可以使用变量，有点类似c语言中的宏定义。使用变量则需要使用$(变量名)这种格式例子如下:123OBJ=main.o test1.o test2.otarget:$(OBJ) gcc -o target $(OBJ) Makefile小知识点由于我所学习Makefile的文章也是来源于一篇笔记，写的很长，我一下子也没能看完，知识点的梳理不算很好，自己无法很好地整理成很好地知识体系，暂且把一些细小知识点记录下来。 没有依赖文件的目标文件:其实这个在我们平常书写的makefile中非常常见，见得最多的就是make clean这个命令了，通常书写makefile都会写一个clean目标，用来清空自己编译留下的文件。是不是很奇怪clean这个目标文件之后没有任何的依赖文件12clean: rm -rf *.o target 还记得上文说的makefile工作原理吗?make命令会寻找makefile文件中的第一个目标文件，如果我们把上边例子中的内容放在makefile文件最前面，那么它会无条件的执行下面的删除命令(除非当前目录存在一个名字叫做clean的文件),没有依赖文件也就不会去对比目标文件和依赖文件的修改时间。所以通常上边例子中的内容通常会放在makefile文件最下边，通过make clean指定来执行。当然如果存在了clean文件，我们也有办法执行下边的命令，这就得用到伪目标、 .POHOY：通过.PHONY声明的目标，即使当前目录下存在目标文件，也会去执行下边的命令 123.POHNY:cleanclean: rm -rf *.o target 指定执行某个makefile文件:这得用到make命令的-f参数,make -f 文件名,这样子也就可以指定执行当前目录下某个makefile文件 include:这个有点类似c语言的包含头文件，在一个主makefile文件中包含其他子makefile文件，如果包含的文件不在当前目录下，使用make命令时可以使用-I参数来指定目录，和gcc编译的-i参数一模一样。 显示命令:通常书写的makefile文件运行时，都会在终端上打印所执行的命令，如果想要不打印，我们可以再命令前加上@符号 命令出错:每个命令运行完毕，make会检测每个命令的返回值，如果成功继续往下运行，否则终止当前运行并退出，如果想要忽略错误，可以在命令前加上 - 符号","tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Python之生成器","date":"2018-12-02T12:09:20.000Z","path":"2018/12/02/Python之生成器/","text":"生成器利用迭代器，我们可以在每次迭代获取数据（通过next()方法）时按照特定的规律进行生成。但是我们在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。为了达到记录当前状态，并配合next()函数进行迭代使用，我们可以采用更简便的语法，即生成器(generator)。生成器是一类特殊的迭代器。 创建生成器方法1列表生成式列表生成式是Python用来生成一个列表的一种简便语法 语法格式:[生成结果表达式 for 元素 in 可迭代对象]例子:12L = [x*2 for x in range(10)]print(L) 运行结果:1[0, 2, 4, 6, 8, 10, 12, 14, 16, 18] 上面是一个简单的列表生成式，其实这东西还可以写的非常复杂，不过本章不是主要讲列表生成式，是为了讲生成器做个基础介绍，就不详细介绍。 生成器生成方法第一种方法很简单，只要把一个列表生成式的 [ ] 改成 ( )123456789In [15]: L = [ x*2 for x in range(5)]In [16]: LOut[16]: [0, 2, 4, 6, 8]In [17]: G = ( x*2 for x in range(5))In [18]: GOut[18]: &lt;generator object &lt;genexpr&gt; at 0x7f626c132db0&gt; 创建 L 和 G 的区别仅在于最外层的 [ ] 和 ( ) ， L 是一个列表，而 G 是一个生成器。我们可以直接打印出列表L的每一个元素，而对于生成器G，我们可以按照迭代器的使用方法来使用，即可以通过next()函数、for循环、list()等方法使用。123456789101112131415161718192021222324In [19]: next(G)Out[19]: 0In [20]: next(G)Out[20]: 2In [21]: next(G)Out[21]: 4In [22]: next(G)Out[22]: 6In [23]: next(G)Out[23]: 8In [24]: next(G)---------------------------------------------------------------------------StopIteration Traceback (most recent call last)&lt;ipython-input-24-380e167d6934&gt; in &lt;module&gt;()----&gt; 1 next(G)StopIteration:In [25]: 123456789101112In [26]: G = ( x*2 for x in range(5))In [27]: for x in G: ....: print(x) ....: 02468In [28]: 创建生成器方法2generator非常强大。如果推算的算法比较复杂，用类似列表生成式的 for 循环无法实现的时候，还可以用函数来实现。我们仍然用迭代器中介绍的斐波那契数列来举例，用迭代器的实现方式：1234567891011121314151617181920212223class Fib(object): def __init__(self,n): self.n = n self.a = 0 self.b = 1 self.current_idx = 0 def __iter__(self): return self def __next__(self): if self.current_idx &lt; self.n: tmp_val = self.a self.a,self.b = (self.b,self.a + self.b) self.current_idx +=1 return tmp_val else: raise StopIterationif __name__ == \"__main__\": f = Fib(10) for i in f: print(i) 现在我们用生成器来实现一下。123456789101112131415161718def Fib(num): a = 0 b = 1 cnt = 0 while cnt &lt; num: cnt +=1 tmp = a a,b = b,a+b yield tmp return \"end\" if __name__ == \"__main__\": f = Fib(10) for i in f: print(\"%d \"%i,end=\"\") print() 运行结果:10 1 1 2 3 5 8 13 21 34 在使用生成器实现的方式中，我们将原本在迭代器next方法中实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的return换成了yield，此时新定义的函数便不再是函数，而是一个生成器了。简单来说：只要在def中有yield关键字的 就称为 生成器。此时按照调用函数的方式( 案例中为f = fib(10) )使用生成器就不再是执行函数体了，而是会返回一个生成器对象（ 案例中为f ），然后就可以按照使用迭代器的方式来使用生成器了。 使用send唤醒我们除了可以使用next()函数来唤醒生成器继续执行外，还可以使用send()函数来唤醒执行。使用send()函数的一个好处是可以在唤醒的同时向断点处传入一个附加数据。 例子：执行到yield时，gen函数作用暂时保存，返回i的值; temp接收下次c.send(“python”)，send发送过来的值，c.next()等价c.send(None)12345678910def gen(): while True: val = yield \"hello\" print(val)if __name__ == \"__main__\": g = gen() print(g.send(None)) print(g.send(\"python\")) 运行结果:123hellopythonhello 第一次使用send的时候不可以传非None参数进去，因为第一次的时候，yield把”hello”返回后就相当于处于断点，此时send过去的数据接收不到。当第二次的时候，程序停在val引用一个数值的地方，send发送过去的数据正好接收 总结 使用了yield关键字的函数不再是函数，而是生成器。（使用了yield的函数就是生成器） yield关键字有两点作用： 保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起 将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用 可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数）","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python之迭代器","date":"2018-11-29T12:53:25.000Z","path":"2018/11/29/Python之迭代器/","text":"迭代器迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 可迭代对象在Python中，可以通过for … in …方式进行遍历内部元素的，称之为可迭代对象，就比如list,字典，元祖等类型 如何判断一个对象是否是可迭代对象可以通过isinstance函数来判定，代码示例:1234from collection import Iterableisinstance([],Iterable)isinstance(&#123;&#125;,Iterable) 注意上边的[] {}返回的是一个空的列表 字典对象，可能这种写法比较奇怪通过isinstance的返回值，是True的话就是可迭代对象，是False就是不可迭代的 可迭代对象的本质我们分析对可迭代对象进行迭代使用的过程，发现每迭代一次（即在for…in…中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)。可迭代对象的本质就是可以向我们提供一个这样的中间“人”即迭代器帮助我们对其进行迭代遍历使用。 可迭代对象通过iter方法向我们提供一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据. 那么也就是说，一个具备了iter方法的对象，就是一个可迭代对象。下面代码实现自己的列表:1234567891011121314151617from collections import Iterableclass MyList(object): def __init__(self): self.inner_list = list() def __iter__(self): pass def add(self,val): self.inner_list.append(val)if __name__ == \"__main__\": ml = MyList() ml.add(1) ml.add(2) ml.add(3) print(isinstance(ml,Iterable)) 运行结果:1True 说明有了iter方法之后，就是一个可迭代对象了 iter()函数和next()函数list、tuple等都是可迭代对象，我们可以通过iter()函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用next()函数来获取下一条数据。iter()函数实际上就是调用了可迭代对象的iter方法。代码示例:12345678li = [1,2,3,4,5]it = iter(li)print(next(it))print(next(it))print(next(it))print(next(it))print(next(it)) 运行结果:1234512345 如何判断一个对象是否是迭代器可以使用instance函数判断1234from collections import Iteratorprint(\"list is Iterator?\",isinstance([],Iterator))print(\"iter(list) is Iterator?\",isinstance(iter([]),Iterator)) 运行结果:12list is Iterator? Falseiter(list) is Iterator? True 迭代器Iterator通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用next()函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。实际上，在使用next()函数的时候，调用的就是迭代器对象的next方法（Python3中是对象的next方法，Python2中是对象的next()方法）。所以，我们要想构造一个迭代器，就要实现它的next方法。但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现iter方法，而iter方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的iter方法返回自身即可。 一个实现了iter方法和next方法的对象，就是迭代器。1234567891011121314151617181920212223242526272829303132333435class MyList(object): def __init__(self): self.inner_list = list() def add(self,val): self.inner_list.append(val) def __iter__(self): return MyIterator(self)class MyIterator(object): def __init__(self,my_list): self.current_idx = 0; self.inner_list = my_list.inner_list def __iter__(self): return self def __next__(self): if self.current_idx &lt; len(self.inner_list): tmp_val = self.inner_list[self.current_idx] self.current_idx +=1 return tmp_val else: raise StopIterationif __name__ == \"__main__\": ml = MyList() ml.add(1) ml.add(2) ml.add(3) ml.add(4) ml.add(5) for i in ml: print(i) 运行结果:1234512345 for … in …的本质通过上面的代码例子，我们不妨来分析下for循环的本质。首先通过对象内部iter方法返回迭代器对象，然后不断地调用迭代器对象内部的next方法，返回内部元素。知道遇到StopIteration异常结束。 迭代器妙用我们发现迭代器最核心的功能就是可以通过next()函数的调用来返回下一个数据值。如果每次返回的数据值不是在一个已有的数据集合中读取的，而是通过程序按照一定的规律计算生成的，那么也就意味着可以不用再依赖一个已有的数据集合，也就是说不用再将所有要迭代的数据都一次性缓存下来供后续依次读取，这样可以节省大量的存储（内存）空间。 举个例子，比如，数学中有个著名的斐波拉契数列（Fibonacci），数列中第一个数为0，第二个数为1，其后的每一个数都可由前两个数相加得到： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, … 现在我们想要通过for…in…循环来遍历迭代斐波那契数列中的前n个数。那么这个斐波那契数列我们就可以用迭代器来实现，每次迭代都通过数学计算来生成下一个数。1234567891011121314151617181920212223class Fib(object): def __init__(self,n): self.n = n self.a = 0 self.b = 1 self.current_idx = 0 def __iter__(self): return self def __next__(self): if self.current_idx &lt; self.n: tmp_val = self.a self.a,self.b = (self.b,self.a + self.b) self.current_idx +=1 return tmp_val else: raise StopIterationif __name__ == \"__main__\": f = Fib(10) for i in f: print(i) 运行结果:123456789100112358132134 并不是只有for循环能接收可迭代对象除了for循环能接收可迭代对象，list、tuple等也能接收。1234li = list(Fib(10))print(li)tu = tuple(Fib(10))print(tu) 运行结果:12[0, 1, 1, 2, 3, 5, 8, 13, 21, 34](0, 1, 1, 2, 3, 5, 8, 13, 21, 34)","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"心情随笔","date":"2018-11-29T12:01:09.000Z","path":"2018/11/29/心情随笔/","text":"最近遭受的事情真是有点多，每天上班下班的生活，一天天的，在公司也没什么开发需求，代码写不了多少。感觉技术提升很缓慢，这也正是我晚上回来想学学习点新知识的原因之一吧！距离自己还没毕业的实习，到现在正式工作，入了自己很喜欢的行业，也已经快有一年时间了。曾经自己刚出来找工作的时候，怕公司不要我，对于工资这一块完全没有任何想法，能让我进公司干就行了，自己喜欢的事情，真不在乎工资。我在大学的时候想过，以后自己会做什么？看到自己高中同学朋友毕业的早一点的，已经工作了。而自己以后到底能干嘛？从那时候起，我才正视我所喜欢的东西，我喜欢计算机，以后可以做程序员。之后，我甚至有这样的感觉：以后自己不做程序员的话，真想不到我还能做其他的工作了。还好，得益于此，现在的我一点都不后悔当初的选择，并且未来还有很多值得我努力奋斗的。现在想想那时候的自己，也并不会有觉得任何天真之类的感觉。毕竟自己的路都是一步步过来的，我总会慢慢成长有所蜕变的。之前跳了一次槽，现在这份工作也已经干了快四个月了吧，做的是银行的卡前置系统。纯c代码编写，代码量还挺多的，不过我运气还不错，遇到了个大牛师傅，在他的带领下，我慢慢地了解了整个系统的模块架构，可以进行交易的开发，也可以配合测试人员或者其他系统的人快速定位问题，帮助他们解决遇到的问题。进来，感觉到自己对系统的细节还不熟悉，在公司花时间把整个系统代码模块从前往后一点点的看，争取能把百分之八十的细节都看懂，看着别人写的代码，自己也可以学到很多。晚上回来学学自己挺喜欢的语言python，对于python，我的感觉是很是实用，开发快，做点小东西很好。前段时间就自己动手写了个京东抢券的爬虫，和一个爬取企查查企业信息的爬虫，如果用c来写，且不说我能不能做得出来，我得花很多时间来学习底层的一些机制，再自己写出来，很麻烦。比如https请求涉及到的证书，加密这一类东西，估计自己花上一个月的晚上时间都不一定搞得出来吧。不过c语言来做能更加清楚了解底层的知识，理解更加透彻。语言这东西并不能说谁好谁坏，只是在适当的时候选择合适的语言来进行开发，会事半功倍。 自己每天晚上回来，基本上都会学一学python，只是今天回头想想，好多知识点我又忘记了，真是有点可惜。我写博客记录下自己所学的基础知识，是怕自己会忘记，不记下来就什么都没有了，记录下来，以后用到的时候可以看看自己写的博客，看自己写的东西，肯定比别人的要理解得快，毕竟都是自己曾经的思路。现在的我博客上并没有任何自己在某一方面有自己的领悟的知识点，比如linux内核，网络的深奥知识，现在的我要写这些东西还远远不够，以后有自己有所领悟的领域，我应该也会写下来吧，能帮助自己梳理知识，也希望自己的见解可以帮助到其他的人，这还是挺好的。","tags":[]},{"title":"python之装饰器(进阶版)","date":"2018-11-25T14:12:58.000Z","path":"2018/11/25/python之装饰器-进阶版/","text":"有了上一篇装饰器原理的简单介绍，那么可以来探索下装饰器的一些高级用法 装饰器之装饰有参数的函数简单版本的装饰有参数函数上一篇中提到的语法糖装饰器语法是 @函数名 这种格式，相当与 被装饰的函数名 = 函数名(被装饰的函数名) 这样的情况，代码例子如下:12345678def decorator(func): def wrapper(): func() return wrapper@decoratordef test(): print(\"test\") 上面@decorator 也就相当于 test = decorator(test),那么，如果test函数带有参数的情况下，改怎么装饰呢？如果我们不对原有装饰器进行改变，还是用原来的来装饰一个有参数的函数的话，python解释器会提示缺少参数错误。如下代码的例子:12345678910def decorator(func): def wrapper(): func() return wrapper@decoratordef test(arg): print(\"test\",arg)test(\"helloworld\") 运行结果：1234Traceback (most recent call last): File &quot;demo6.py&quot;, line 10, in &lt;module&gt; test(&quot;helloworld&quot;)TypeError: wrapper() takes 0 positional arguments but 1 was given 提示我们wrapper函数调用缺少参数，那么我们不妨从 test = decorator(test) 这行代码的内部运行流程来理解下为啥会出现这样的错误，当 decorator(test) 调用时，返回内部定义的wrapper函数变量，而test是带有参数的，用来引用一个没有参数的wrapper，就报错了。明白了这一点，那么接下来我们就好办，修改代码如下:12345678910def decorator(func): def wrapper(arg): func(arg) return wrapper@decoratordef test(arg): print(\"test\",arg)test(\"helloworld\") 运行结果:1test helloworld 没有任何的问题，好了，这只是一种简单版本的带参数函数装饰器，接下来再看看通用版本的。 通用版本的装饰有参数函数装饰器考虑到一个装饰器的通用性，实际开发过程中可能不仅要装饰一个参数的函数，也可能装饰带有多个参数的函数，就比如要在原有的函数之上添加日志记录功能，原有函数有很多，参数也不尽相同，那么就要写一个通用版本的装饰器。相信大家都学过python的可变长参数这个知识点，函数参数列表中参数名前面加上*，代表传递多个除字典以外普通类型的参数，写上**的话，代表传递多个字典参数，有了这个知识点的基础，那么实现一个通用版本装饰器就很简单，修改上面代码如下:12345678910111213141516def decorator(func): def wrapper(*args,**kwargs): func(*args,*kwargs) return wrapper@decoratordef test1(arg): print(\"test\",arg)@decoratordef test2(arg1,arg2,arg3): print(\"test\",arg1,arg2,arg3)test1(\"helloworld\")test2(\"hello\",\"world\",\"python\") 运行结果:12test helloworldtest hello world python 好了，上面这个装饰器则能满足装饰任何参数个数的函数 装饰带有返回值的函数平时开发过程中，有返回值的函数非常之多，有时候我们要依靠返回值来判断函数执行是否达到了我们的预期效果，那么如何来装饰一个有返回值的函数呢?就比如下面这段代码，我们来装饰一个有返回值的函数12345678910def makeBold(func): def wrapper(*args,**kwargs): func(*args,**kwargs) return wrapper@makeBolddef get_str(info): return infoprint(get_str(\"hello world\")) 运行结果:1None 咦？我们的get_str函数明明有返回值，装饰过后为啥没了呢？原因很简单，因为在内部wrapper函数中，并没有任何的返回值，它仅仅只是调用了一下get_str函数。那么我们不妨对调用函数的结果进行返回，看看情况会怎么样?12345678910def makeBold(func): def wrapper(*args,**kwargs): return \"&lt;b&gt;\" + func(*args,**kwargs) + \"&lt;/b&gt;\" return wrapper@makeBolddef get_str(info): return infoprint(get_str(\"hello world\")) 运行结果:1&lt;b&gt;hello world&lt;/b&gt; 结果在我们的期望之中，那么装饰带有返回值的函数，可以这么来做。 多个装饰器装饰一个函数这个知识点的话先讲原理不太好，我们先从代码的运行结果来看，再进行分析多个装饰器装饰一个函数是怎么样的一个过程123456789101112131415161718192021def add_verity1(func): print(\"装饰验证1功能\") def wrapper(*args,**kwargs): print(\"---验证1功能执行---\") return func(*args,**kwargs) return wrapperdef add_verity2(func): print(\"装饰验证2功能\") def wrapper(*args,**kwargs): print(\"---验证2功能执行---\") return func(*args,**kwargs) return wrapper@add_verity1@add_verity2def test(): print(\"---test---\")test() 运行结果:12345装饰验证2功能装饰验证1功能---验证1功能执行------验证2功能执行------test--- 从运行结果来看，显示装饰了下面verity2的功能，再装饰verity1，函数调用时候是先运行验证1，再运行验证2，最后调用之前函数本身。其实这也不难理解，先装饰verity2，也就是test = add_verity2(test)，此时的test已经变成了引用add_verity2内部的wrapper函数，那么自然也就带上了验证2的功能，然后再装饰verity1，test = add_verity1(test)，此时带上了验证2功能的test再来引用add_verity1内部的wrapper函数。 装饰器带参数如果一个装饰器要可以根据程序员传递的参数来进行装饰不同的功能，可以对装饰器也增加参数，这一点稍微有点复杂，且看代码再来理解123456789101112131415161718192021222324252627def add_verity(verity_type): if verity_type == \"验证1\": def outer_wrapper(func): def inner_wrapper(*args,**kwargs): print(\"---验证1功能执行---\") return func(*args,**kwargs) return inner_wrapper return outer_wrapper elif verity_type == \"验证2\": def outer_wrapper(func): def inner_wrapper(*args,**kwargs): print(\"---验证2功能执行---\") return func(*args,**kwargs) return inner_wrapper return outer_wrapper@add_verity(verity_type=\"验证1\")def test1(): print(\"---test1---\")@add_verity(verity_type=\"验证2\")def test2(): print(\"---test2---\")test1()test2() 运行结果:1234---验证1功能执行------test1------验证2功能执行------test2--- 这样子我们就可以对装饰器传递参数来选择装饰功能，那么上面这一装饰器装饰过程又是怎么样的呢?12341.@add_verity(verity_type=&quot;验证1&quot;)，这行代码，首先是对add_verity(verity_type=&quot;验证1&quot;)的调用2.调用完毕，内部根据传递的参数，运行不同的if分之，假如参数是&quot;验证1&quot;，也就会把验证1分之内部的outer_wrapper引用返回回去，此时也就相当于 @验证1分之下的outer_wrapper3.这样子接下来的就好理解了，test1 = outer_wrapper(test1)，也就是test1引用了验证1分之内部的inner_wrapper函数test2装饰的原理同上 呼~终于熬夜把装饰器的知识点写完了","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python之装饰器","date":"2018-11-25T04:05:14.000Z","path":"2018/11/25/Python之装饰器/","text":"装饰器是python里面比较重要的内容之一，就我个人学习装饰器的历程而言，真是装饰器虐我千百遍，我待装饰器如初恋。。。这东西来来回回学了好多遍，当时是搞明白了，可是工作不会用到，过段时间，回过头来想想装饰器是啥？它的原理是什么？我就又不记得了，所以还是记下来比较好吧！ 装饰器介绍装饰器是一种用来装饰函数的函数，它有两个原则:1.在不改变原函数的代码的情况下装饰函数 2.在不改变原函数调用方式的情况下装饰函数 函数及变量在python中，函数名也是一个变量，可以有赋值等操作。其实在c语言中，函数名的本质也就是一个指向此函数名对应的函数的代码段，有c语言基础可能理解这一点会比较容易代码示例如下:12345def func(): print(\"this is a func\")a = funca() 这段代码运行结果就是”this is a func”，给a赋值func后，a也就是这个函数类型，当然赋值时候不可以在后面加括号，加了括号就是调用函数了，会把func的返回值赋值给a，没有的话a就等于None，在c语言中这么做的话要用函数指针，这一点来说python方便太多了 函数内定义函数有了上面的基础，那么再来看看在函数体内定义函数的情况是咋样的1234567def outer_func(): print(\"before inner_func\") def inner_func(): print(\"i am inner_func\") print(\"after inner_func\")outer_func() 运行结果:12before inner_funcafter inner_func 从运行结果来看，里边定义的函数并没有被调用，也仅仅只是定义的情况，当然我们可以在内部进行调用，对上面代码稍作修改12345678def outer_func(): print(\"before inner_func\") def inner_func(): print(\"i am inner_func\") print(\"after inner_func\") inner_func()outer_func() 运行结果:123before inner_funcafter inner_funci am inner_func 说明在内部调用了inner_func函数 装饰器雏形有了上面两个小知识点的基础，那么就可以来讲一下装饰器了，先自己写一个装饰器原理分解代码,用来统计函数运行时间的装饰函数12345678910111213141516171819202122232425import timedef timer(func): print(func) def wrapper(): start_time = time.time() func() end_time = time.time() print(\"run time is %s\"%(end_time-start_time)) return wrapperdef test1(): time.sleep(2) print(\"this is test1\")def test2(): time.sleep(4) print(\"this is test2\")test1 = timer(test1)test2 = timer(test2)test1()test2() 运行结果如下:123456&lt;function test1 at 0x7f208c7ad510&gt;&lt;function test2 at 0x7f208c7ada60&gt;this is test1run time is 2.002680540084839this is test2run time is 4.004958152770996 解释:上面的代码，前部分都是函数定义部分，没有调用，真正看到程序运行流程的是从test1 = timer(test1),这里开始往后，那么我就从这行代码开始分析。这行代码就是把test1当做参数传给timer函数调用timer，然后把返回结果赋值给test1。那么调用timer的流程就是先打印传递进去的参数，也就是test1，然后定义了一个内部的wrapper函数，wrapper在内部只是定义，并不会被调用。接下来返回wrapper，此时test1就变成了wrapper，test2过程也和上面一样。接下来调用test1，就变成了调用内部的wrapper，那么结果不就显而易见了。 装饰器之语法糖上面就是装饰器的原理分解，当然python语言提供了一个简便的方法，让我们来实现装饰器，也就是装饰器语法糖，在定义函数之前 @函数名 ,就可以使用装饰器了，把上面代码稍作修改:123456789101112131415161718192021222324import timedef timer(func): print(func) def wrapper(): start_time = time.time() func() end_time = time.time() print(\"run time is %s\"%(end_time-start_time)) return wrapper@timerdef test1(): time.sleep(2) print(\"this is test1\")@timerdef test2(): time.sleep(4) print(\"this is test2\")test1()test2() 运行一下，发现逻辑和上面完全一致(统计时间会有所变化)。也就是这种语法糖的效果就相当于我们写的test1 = timer(test1) 好了，装饰器的介绍先告一段落，之后再讲它的一些进阶用法。","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"CSS基础知识","date":"2018-11-21T15:10:13.000Z","path":"2018/11/21/CSS基础知识/","text":"css基本语法及页面引用css基本语法css的定义方法是： 选择器 { 属性:值; 属性:值; 属性:值;} 选择器是将样式和页面元素关联起来的名称，属性是希望设置的样式属性每个属性有一个或多个值。代码示例：12345678910/* css注释 ctrl+shift+\"/\"*/div&#123; width:100px; height:100px; color:red &#125; css页面引入方法：1、外联式：通过link标签，链接到外部样式表到页面中。1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"&gt; 2、嵌入式：通过style标签，在网页上创建嵌入的样式表。1234&lt;style type=\"text/css\"&gt; div&#123; width:100px; height:100px; color:red &#125; ......&lt;/style&gt; 3、内联式：通过标签的style属性，在标签上直接写样式。1&lt;div style=\"width:100px; height:100px; color:red \"&gt;......&lt;/div&gt; css文本设置常用的应用文本的css样式： color 设置文字的颜色，如： color:red; font-size 设置文字的大小，如：font-size:12px; font-family 设置文字的字体，如：font-family:’微软雅黑’; font-style 设置字体是否倾斜，如：font-style:’normal’; 设置不倾斜，font-style:’italic’;设置文字倾斜 font-weight 设置文字是否加粗，如：font-weight:bold; 设置加粗 font-weight:normal 设置不加粗 line-height 设置文字的行高，设置行高相当于在每行文字的上下同时加间距， 如：line-height:24px; font 同时设置文字的几个属性，写的顺序有兼容问题，建议按照如下顺序写： font：是否加粗 字号/行高 字体；如： font:normal 12px/36px ‘微软雅黑’; text-decoration 设置文字的下划线，如：text-decoration:none; 将文字下划线去掉 text-indent 设置文字首行缩进，如：text-indent:24px; 设置文字首行缩进24px 行高示例图片 text-align 设置文字水平对齐方式，如text-align:center 设置文字水平居中 css颜色表示法css颜色值主要有三种表示方法：1、颜色名表示，比如：red 红色，gold 金色2、rgb表示，比如：rgb(255,0,0)表示红色3、16进制数值表示，比如：#ff0000 表示红色，这种可以简写成 #f00 css选择器常用的选择器有如下几种：1、标签选择器标签选择器，此种选择器影响范围大，建议尽量应用在层级选择器中。举例：123456*&#123;margin:0;padding:0&#125;div&#123;color:red&#125; &lt;div&gt;....&lt;/div&gt; &lt;!-- 对应以上两条样式 --&gt;&lt;div class=\"box\"&gt;....&lt;/div&gt; &lt;!-- 对应以上两条样式 --&gt; 2、id选择器通过id名来选择元素，元素的id名称不能重复，所以一个样式设置项只能对应于页面上一个元素，不能复用，id名一般给程序使用，所以不推荐使用id作为选择器。举例：123#box&#123;color:red&#125; &lt;div id=\"box\"&gt;....&lt;/div&gt; &lt;!-- 对应以上一条样式，其它元素不允许应用此样式 --&gt; 3、类选择器通过类名来选择元素，一个类可应用于多个元素，一个元素上也可以使用多个类，应用灵活，可复用，是css中应用最多的一种选择器。举例：1234567.red&#123;color:red&#125;.big&#123;font-size:20px&#125;.mt10&#123;margin-top:10px&#125; &lt;div class=\"red\"&gt;....&lt;/div&gt;&lt;h1 class=\"red big mt10\"&gt;....&lt;/h1&gt;&lt;p class=\"red mt10\"&gt;....&lt;/p&gt; 4、层级选择器主要应用在选择父元素下的子元素，或者子元素下面的子元素，可与标签元素结合使用，减少命名，同时也可以通过层级，防止命名冲突。举例：12345678910.box span&#123;color:red&#125;.box .red&#123;color:pink&#125;.red&#123;color:red&#125;&lt;div class=\"box\"&gt; &lt;span&gt;....&lt;/span&gt; &lt;a href=\"#\" class=\"red\"&gt;....&lt;/a&gt;&lt;/div&gt;&lt;h3 class=\"red\"&gt;....&lt;/h3&gt; 5、组选择器多个选择器，如果有同样的样式设置，可以使用组选择器。举例：12345678.box1,.box2,.box3&#123;width:100px;height:100px&#125;.box1&#123;background:red&#125;.box2&#123;background:pink&#125;.box2&#123;background:gold&#125;&lt;div class=\"box1\"&gt;....&lt;/div&gt;&lt;div class=\"box2\"&gt;....&lt;/div&gt;&lt;div class=\"box3\"&gt;....&lt;/div&gt; 6、伪类及伪元素选择器常用的伪类选择器有hover，表示鼠标悬浮在元素上时的状态，伪元素选择器有before和after,它们可以通过样式在元素中插入内容。12345678.box1:hover&#123;color:red&#125;.box2:before&#123;content:'行首文字';&#125;.box3:after&#123;content:'行尾文字';&#125;&lt;div class=\"box1\"&gt;....&lt;/div&gt;&lt;div class=\"box2\"&gt;....&lt;/div&gt;&lt;div class=\"box3\"&gt;....&lt;/div&gt; CSS盒子模型盒子模型解释元素在页面中显示成一个方块，类似一个盒子，CSS盒子模型就是使用现实中盒子来做比喻，帮助我们设置元素对应的样式。把元素叫做盒子，设置对应的样式分别为：盒子的宽度(width)、盒子的高度(height)、盒子的边框(border)、盒子内的内容和边框之间的间距(padding)、盒子与盒子之间的间距(margin)。 设置宽高12width:200px; /* 设置盒子的宽度，此宽度是指盒子内容的宽度，不是盒子整体宽度(难点) */ height:200px; /* 设置盒子的高度，此高度是指盒子内容的高度，不是盒子整体高度(难点) */ 设置边框设置一边的边框，比如顶部边框，可以按如下设置：1234border-top-color:red; /* 设置顶部边框颜色为红色 */ border-top-width:10px; /* 设置顶部边框粗细为10px */ border-top-style:solid; /* 设置顶部边框的线性为实线，常用的有：solid(实线) dashed(虚线) dotted(点线); */ 上面三句可以简写成一句：1border-top:10px solid red; 设置其它三个边的方法和上面一样，把上面的’top’换成’left’就是设置左边，换成’right’就是设置右边，换成’bottom’就是设置底边。 四个边如果设置一样，可以将四个边的设置合并成一句：1border:10px solid red; 设置内间距padding设置盒子四边的内间距，可设置如下：1234padding-top：20px; /* 设置顶部内间距20px */ padding-left:30px; /* 设置左边内间距30px */ padding-right:40px; /* 设置右边内间距40px */ padding-bottom:50px; /* 设置底部内间距50px */ 上面的设置可以简写如下：1padding：20px 40px 50px 30px; /* 四个值按照顺时针方向，分别设置的是 上 右 下 左 四个方向的内边距值。 */ padding后面还可以跟3个值，2个值和1个值，它们分别设置的项目如下：123padding：20px 40px 50px; /* 设置顶部内边距为20px，左右内边距为40px，底部内边距为50px */ padding：20px 40px; /* 设置上下内边距为20px，左右内边距为40px*/ padding：20px; /* 设置四边内边距为20px */ 设置外间距margin外边距的设置方法和padding的设置方法相同，将上面设置项中的’padding’换成’margin’就是外边距设置方法。 盒模型使用技巧及相关问题margin相关技巧1、设置元素水平居中： margin:x auto;2、margin负值让元素位移及边框合并 外边距合并外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。解决方法如下： 1、使用这种特性2、设置一边的外边距，一般设置margin-top3、将元素浮动或者定位 margin-top 塌陷在两个盒子嵌套时候，内部的盒子设置的margin-top会加到外边的盒子上，导致内部的盒子margin-top设置失败，解决方法如下： 1、外部盒子设置一个边框2、外部盒子设置 overflow:hidden3、使用伪元素类：1234.clearfix:before&#123; content: ''; display:table;&#125; css元素溢出当子元素的尺寸超过父元素的尺寸时，需要设置父元素显示溢出的子元素的方式，设置的方法是通过overflow属性来设置。overflow的设置项：1、visible 默认值。内容不会被修剪，会呈现在元素框之外。2、hidden 内容会被修剪，并且其余内容是不可见的，此属性还有清除浮动、清除margin-top塌陷的功能。3、scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。4、auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。5、inherit 规定应该从父元素继承 overflow 属性的值。 块元素、内联元素、内联块元素元素就是标签，布局中常用的有三种标签，块元素、内联元素、内联块元素，了解这三种元素的特性，才能熟练的进行页面布局。 块元素块元素，也可以称为行元素，布局中常用的标签如：div、p、ul、li、h1~h6、dl、dt、dd等等都是块元素，它在布局中的行为： 支持全部的样式 如果没有设置宽度，默认的宽度为父级宽度100% 盒子占据一行、即使设置了宽度内联元素内联元素，也可以称为行内元素，布局中常用的标签如：a、span、em、b、strong、i等等都是内联元素，它们在布局中的行为： 支持部分样式（不支持宽、高、margin上下、padding上下） 宽高由内容决定 盒子并在一行 代码换行，盒子之间会产生间距 子元素是内联元素，父元素可以用text-align属性设置子元素水平对齐方式解决内联元素间隙的方法1、去掉内联元素之间的换行2、将内联元素的父级设置font-size为0，内联元素自身再设置font-size内联块元素内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的，img和input元素的行为类似这种元素，但是也归类于内联元素，我们可以用display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为： 支持全部样式 如果没有设置宽高，宽高由内容决定 盒子并在一行 代码换行，盒子会产生间距 这三种元素，可以通过display属性来相互转化，不过实际开发中，块元素用得比较多，所以我们经常把内联元素转化为块元素，少量转化为内联块，而要使用内联元素时，直接使用内联元素，而不用块元素转化了。 display属性display属性是用来设置元素的类型及隐藏的，常用的属性有：1、none 元素隐藏且不占位置2、block 元素以块元素显示3、inline 元素以内联元素显示4、inline-block 元素以内联块元素显示","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"html基础知识","date":"2018-11-14T14:13:07.000Z","path":"2018/11/14/html基础知识/","text":"因为我不是做前端开发的，源于对技术的热爱以及公司年会要求做一个抽奖器，我打算用前端做界面，Django做后端,所以想系统学习一下这方面知识。考虑到忘得很快，所以想记录下来，不怕大家笑话，留下来也是自己曾经走过的脚印。 html概述和基本结构html概述HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm，一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。 html基本结构一个html的基本结构如下：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;网页标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页显示内容 &lt;/body&gt;&lt;/html&gt; 第一行是文档声明，第二行“&lt;html&gt;”标签和最后一行“&gt;/html&lt;”定义html文档的整体，“&lt;html&gt;”标签中的‘lang=“en”’定义网页的语言为英文，定义成中文是’lang=”zh-CN”‘,不定义也没什么影响，它一般作为分析统计用。 “&gt;head&lt;”标签和“&gt;body&lt;”标签是它的第一层子元素，“&gt;head&lt;”标签里面负责对网页进行一些设置以及定义标题，设置包括定义网页的编码格式，外链css样式文件和javascript文件等，设置的内容不会显示在网页上，标题的内容会显示在标题栏，“&gt;body&lt;”内编写网页上显示的内容。 HTML文档类型目前常用的两种文档类型是xhtml 1.0和html5xhtml 1.0xhtml 1.0 是html5之前的一个常用的版本，目前许多网站仍然使用此版本。此版本文档用sublime text创建方法： html:xt + tab文档示例：12345678910&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt; xhtml 1.0 文档类型 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; html5pc端可以使用xhtml 1.0，也可以使用html5，html5是向下兼容的此版本文档用sublime text创建方法： html:5 + tab 或者 ! + tab文档示例：12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt; html5文档类型 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 两种文档的区别1、文档声明和编码声明2、html5新增了标签元素以及元素属性 html注释：html文档代码中可以插入注释，注释是对代码的说明和解释，注释的内容不会显示在页面上，html代码中插入注释的方法是：1&lt;!-- 这是一段注释 --&gt; html标题标签通过 &lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;,标签可以在网页上定义6种级别的标题。6种级别的标题表示文档的6级目录层级关系，比如说： &lt;h1&gt;用作主标题，其后是 &lt;h2&gt;，再其次是 &lt;h3&gt;，以此类推。搜索引擎会使用标题将网页的结构和内容编制索引，所以网页上使用标题是很重要的。123&lt;h1&gt;这是一级标题&lt;/h1&gt;&lt;h2&gt;这是二级标题&lt;/h2&gt;&lt;h3&gt;这是三级标题&lt;/h3&gt; html段落标签、换行标签与字符实体html段落标签&lt;p&gt;标签定义一个文本段落，一个段落含有默认的上下间距，段落之间会用这种默认间距隔开，代码如下：1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;段落&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;HTML是 HyperText Mark-up Language 的首字母简写，意思是超文本标记语言，超 文本指的是超链接，标记指的是标签，是一种用来制作网页的语言，这种语言由一个个的 标签组成，用这种语言制作的文件保存的是一个文本文件，文件的扩展名为html或者htm。 &lt;/p&gt; &lt;p&gt;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用文本的方 式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件渲染成网页，显示的网 页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; html换行标签代码中成段的文字，直接在代码中回车换行，在渲染成网页时候不认这种换行，如果真想换行，可以在代码的段落中插入&gt;br /&lt;来强制换行，代码如下：12345&lt;p&gt;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt;文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt;渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt; html字符实体代码中成段的文字，如果文字间想空多个空格，在代码中空多个空格，在渲染成网页时只会显示一个空格，如果想显示多个空格，可以使用空格的字符实体,代码如下：12345&lt;!-- 在段落前想缩进两个文字的空格，使用空格的字符实体：&amp;nbsp; --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;一个html文件就是一个网页，html文件用编辑器打开显示的是文本，可以用&lt;br /&gt;文本的方式编辑它，如果用浏览器打开，浏览器会按照标签描述内容将文件&lt;br /&gt;渲染成网页，显示的网页可以从一个网页链接跳转到另外一个网页。&lt;/p&gt; 在网页上显示 “&gt;” 和 “&lt;” 会误认为是标签，想在网页上显示“&gt;”和“&lt;”可以使用它们的字符实体，比如：12345&lt;!-- “&lt;” 和 “&gt;” 的字符实体为 &amp;lt; 和 &amp;gt; --&gt;&lt;p&gt; 3 &amp;lt; 5 &lt;br&gt; 10 &amp;gt; 5&lt;/p&gt; html块标签、含样式的标签html块标签1、&lt;div&gt; 标签 块元素，表示一块内容，没有具体的语义。2、&lt;span&gt; 标签 行内元素，表示一行中的一小段内容，没有具体的语义。 含样式和语义的标签1、&lt;em&gt; 标签 行内元素，表示语气中的强调词2、&lt;i&gt; 标签 行内元素，表示专业词汇3、&lt;b&gt; 标签 行内元素，表示文档中的关键字或者产品名4、&lt;strong&gt; 标签 行内元素，表示非常重要的内容 语义化的标签语义化的标签，就是在布局的时候多使用有语义的标签，搜索引擎在爬网的时候能认识这些标签，理解文档的结构，方便网站的收录。比如：h1标签是表示标题，p标签是表示段落，ul、li标签是表示列表，a标签表示链接，dl、dt、dd表示定义列表等，语义化的标签不多。 html图像标签、绝对路径和相对路径html图像标签&lt;img&gt;标签可以在网页上插入一张图片，它是独立使用的标签，它的常用属性有： src属性 定义图片的引用地址 alt属性 定义图片加载失败时显示的文字，搜索引擎会使用这个文字收录图片、盲人读屏软件会读取这个文字让盲人识别图片，所以此属性非常重要。1&lt;img src=\"images/pic.jpg\" alt=\"产品图片\" /&gt; 绝对路径和相对路径像网页上插入图片这种外部文件，需要定义文件的引用地址，引用外部文件还包括引用外部样式表，javascript等等，引用地址分为绝对地址和相对地址。 绝对地址：相对于磁盘的位置去定位文件的地址 相对地址：相对于引用文件本身去定位被引用的文件地址绝对地址在整体文件迁移时会因为磁盘和顶层目录的改变而找不到文件，相对路径就没有这个问题。相对路径的定义技巧： “ ./ ” 表示当前文件所在目录下，比如：“./pic.jpg” 表示当前目录下的pic.jpg的图片，这个使用时可以省略。 “ ../ ” 表示当前文件所在目录下的上一级目录，比如：“../images/pic.jpg” 表示当前目录下的上一级目录下的images文件夹中的pic.jpg的图片。 html链接标签&lt;a&gt;标签可以在网页上定义一个链接地址，它的常用属性有： href属性 定义跳转的地址 title属性 定义鼠标悬停时弹出的提示文字框 target属性 定义链接窗口打开的位置 target=”_self” 缺省值，新页面替换原来的页面，在原来位置打开 target=”_blank” 新页面会在新开的一个浏览器窗口打开123&lt;a href=\"#\"&gt;&lt;/a&gt; &lt;!-- # 表示链接到页面顶部 --&gt;&lt;a href=\"http://www.itcast.cn/\" title=\"跳转的传智播客网站\"&gt;传智播客&lt;/a&gt;&lt;a href=\"2.html\" target=\"_blank\"&gt;测试页面2&lt;/a&gt; html列表有序列表在网页上定义一个有编号的内容列表可以用&lt;ol&gt;、&lt;li&gt;配合使用来实现，代码如下：12345&lt;ol&gt; &lt;li&gt;列表文字一&lt;/li&gt; &lt;li&gt;列表文字二&lt;/li&gt; &lt;li&gt;列表文字三&lt;/li&gt;&lt;/ol&gt; 无序列表在网页上定义一个无编号的内容列表可以用&lt;ul&gt;、&lt;li&gt;配合使用来实现，代码如下：12345&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻标题一&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻标题二&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新闻标题三&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 在网页上生成的列表，每条项目上会有一个小图标，这个小图标在不同浏览器上显示效果不同，所以一般会用样式去掉默认的小图标，如果需要图标，可以用样式自定义图标，从而达到在不同浏览器上显示的效果相同,实际开发中一般用这种列表。 定义列表定义列表通常用于术语的定义。&lt;dl&gt;标签表示列表的整体。&lt;dt&gt;标签定义术语的题目。&lt;dd&gt;标签是术语的解释。一个&lt;dl&gt;中可以有多个题目和解释，代码如下：123456789101112&lt;h3&gt;前端三大块&lt;/h3&gt;&lt;dl&gt; &lt;dt&gt;html&lt;/dt&gt; &lt;dd&gt;负责页面的结构&lt;/dd&gt; &lt;dt&gt;css&lt;/dt&gt; &lt;dd&gt;负责页面的表现&lt;/dd&gt; &lt;dt&gt;javascript&lt;/dt&gt; &lt;dd&gt;负责页面的行为&lt;/dd&gt;&lt;/dl&gt; html表单表单用于搜集不同类型的用户输入，表单由不同类型的标签组成，相关标签及属性用法如下： 1、&lt;form&gt;标签 定义整体的表单区域 action属性 定义表单数据提交地址method属性 定义表单提交的方式，一般有“get”方式和“post”方式2、&lt;label&gt;标签 为表单元素定义文字标注 3、&lt;input&gt;标签 定义通用的表单元素 type属性 type=”text” 定义单行文本输入框 type=”password” 定义密码输入框 type=”radio” 定义单选框 type=”checkbox” 定义复选框 type=”file” 定义上传文件 type=”submit” 定义提交按钮 type=”reset” 定义重置按钮 type=”button” 定义一个普通按钮 type=”image” 定义图片作为提交按钮，用src属性定义图片地址 type=”hidden” 定义一个隐藏的表单域，用来存储值 value属性 定义表单元素的值 name属性 定义表单元素的名称，此名称是提交数据时的键名4、&lt;textarea&gt;标签 定义多行文本输入框 5、&lt;select&gt;标签 定义下拉表单元素 6、&lt;option&gt;标签 与&lt;select&gt;标签配合，定义下拉表单元素中的选项 注册表单实例：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;form action=\"http://www...\" method=\"get\"&gt;&lt;p&gt;&lt;label&gt;姓名：&lt;/label&gt;&lt;input type=\"text\" name=\"username\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;密码：&lt;/label&gt;&lt;input type=\"password\" name=\"password\" /&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;性别：&lt;/label&gt;&lt;input type=\"radio\" name=\"gender\" value=\"0\" /&gt; 男&lt;input type=\"radio\" name=\"gender\" value=\"1\" /&gt; 女&lt;/p&gt;&lt;p&gt;&lt;label&gt;爱好：&lt;/label&gt;&lt;input type=\"checkbox\" name=\"like\" value=\"sing\" /&gt; 唱歌&lt;input type=\"checkbox\" name=\"like\" value=\"run\" /&gt; 跑步&lt;input type=\"checkbox\" name=\"like\" value=\"swiming\" /&gt; 游泳&lt;/p&gt;&lt;p&gt;&lt;label&gt;照片：&lt;/label&gt;&lt;input type=\"file\" name=\"person_pic\"&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;个人描述：&lt;/label&gt;&lt;textarea name=\"about\"&gt;&lt;/textarea&gt;&lt;/p&gt;&lt;p&gt;&lt;label&gt;籍贯：&lt;/label&gt;&lt;select name=\"site\"&gt; &lt;option value=\"0\"&gt;北京&lt;/option&gt; &lt;option value=\"1\"&gt;上海&lt;/option&gt; &lt;option value=\"2\"&gt;广州&lt;/option&gt; &lt;option value=\"3\"&gt;深圳&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=\"submit\" name=\"\" value=\"提交\"&gt;&lt;!-- input类型为submit定义提交按钮 还可以用图片控件代替submit按钮提交，一般会导致提交两次，不建议使用。如： &lt;input type=\"image\" src=\"xxx.gif\"&gt;--&gt;&lt;input type=\"reset\" name=\"\" value=\"重置\"&gt;&lt;/p&gt;&lt;/form&gt; html表格1、&lt;table&gt;标签：声明一个表格，它的常用属性如下： border属性 定义表格的边框，设置值是数值 cellpadding属性 定义单元格内容与边框的距离，设置值是数值 cellspacing属性 定义单元格与单元格之间的距离，设置值是数值 align属性 设置整体表格相对于浏览器窗口的水平对齐方式,设置值有：left | center | right2、&lt;tr&gt;标签：定义表格中的一行 3、&lt;td&gt;和&lt;th&gt;标签：定义一行中的一个单元格，td代表普通单元格，th表示表头单元格，它们的常用属性如下： align 设置单元格中内容的水平对齐方式,设置值有：left | center | right valign 设置单元格中内容的垂直对齐方式 top | middle | bottom colspan 设置单元格水平合并，设置值是数值 rowspan 设置单元格垂直合并，设置值是数值","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"MySQL学习之链接查询","date":"2018-11-12T13:36:48.000Z","path":"2018/11/12/MySQL学习之链接查询/","text":"交叉链接 交叉链接的结果可以称之为笛卡尔积,把左表中的数据每一行都与右表中所有行相结合,形成的新表的行数是 左表数据行数*右表数据行数,示例如下 左表 id 姓名 1 小王 2 小李 右表 id 班级 1 一班 2 二班 交叉链接查询结果 id 姓名 id 班级 1 小王 1 一班 1 小王 2 二班 2 小李 1 一班 2 小李 2 二班 交叉链接SQL语句1select * from students cross join classes; 内链接 仅将两个表中满足连接条件的行组合起来作为结果集。在内连接中，只有在两个表中匹配的行才能在结果集中出现等值链接 在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列不等值链接 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;自然链接 在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列SQL语句1select 列名 from 左表 inner join 右表 on 左表.xxx = 右表.xxx; 外链接 外联接可以是左向外联接、右向外联接或完整外部联接。在内连接的基础上，还包含表中所有不符合条件的数据行，并将相对应的表列填写NULL左外链接 （左–对应右NULL）1select 列名 from 左表 left join 右表 on 左表.xxx = 右表.xxx; 右外链接 （右–对应左NULL）1select 列名 from 左表 right join 右表 on 左表.xxx = 右表.xxx; 全外链接 完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。1select 列名 from 左表 full join 右表 on 左表.xxx = 右表.xxx; 不过这条全外链接语句我用MySQL测试的时候报错了,还有待验证…","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Unix编程之getopt getopt_long的使用","date":"2018-11-08T15:16:47.000Z","path":"2018/11/08/Unix编程之getopt-getopt-long的使用/","text":"最近在看goaccess源码时候，没想到一开头就被getopt_long这个函数给卡住了。。。不禁感慨自己离大牛的差距真是太大了，没办法，慢慢学习积累，希望自己的坚持早晚能导致自己的质变吧。百度的时候发现了还有getopt这个函数，算是简化版本吧，只支持单字符的命令解析，做linux大型软件开发通常都离不开用户命令参数，下面就来把自己今晚所学到的小小知识点记录下来，以后也能让自己的代码越写越棒! getopt 以下是摘自manpage中对getopt函数相关参数以及相关变量的展示,接下来对每个参数以及变量进行说明一下 1234567#include &lt;unistd.h&gt;int getopt(int argc, char * const argv[], const char *optstring);extern char *optarg;extern int optind, opterr, optopt; argc、argv这两个参数是c语言程序运行的参数变量，通过main函数传递进来，argc代表参数个数，argv是字符串参数数组 optstring这个参数是getopt函数所依赖的参数解释字符串,规则是：字符串中的单独一个字符代表了命令行传递的一个参数,字符后面如果没有冒号,则代表此参数没有对应值,如果有一个或者两个冒号,代表了参数后面有值,一个冒号支持两种传递参数值的方法,值紧挨着参数或者与参数隔一个空格,如果有两个冒号,仅支持紧挨着的写法,比如 “ab:c::d”这个字符串： a参数后面没有任何值 b参数后面有值，可以通过 -b100或者-b 100方式传递 c参数后面有值,只可以通过 -c100的方式传递 d参数后面没有任何值 optarg这是一个char型指针,指向当前参数的值 optind是下一个argv的索引 optopt 不知道什么作用…. opterr如果不希望getopt()打印出错信息，则只要将全域变量opterr设为0即可。 getopt返回值,如果有参数为当前参数字符,没有参数返回-11234567891011121314#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc,char *argv[])&#123; char opt; const char *optstring = \"ab:c::d\"; while((opt = getopt(argc,argv,optstring)) != -1)&#123; printf(\"%c:%s\\t\",opt,optarg); printf(\"optind=%d\\t\",optind); printf(\"next opt is %s\\t\",argv[optind]); printf(\"optopt:%d\\n\",optopt); &#125; return 0;&#125; 编译之后运行效果如下:12345./app -a -b 200 -c100 -da:(null) optind=2 next opt is -b optopt:0b:200 optind=4 next opt is -c100 optopt:0c:100 optind=5 next opt is -d optopt:0d:(null) optind=6 next opt is (null) optopt:0 以上就是getopt的大致用法 getopt_longgetopt_long保留了getopt的用法，并且支持长参数,就是不是单个字符的选项参数12345#include &lt;getopt.h&gt;int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex); 前三个参数和getopt基本上一致 longopts:长参数的结构体配置 longindex:如果longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值 返回值:对于短选项，返回值同getopt函数；对于长选项，如果flag是NULL，返回val，否则返回0；对于错误情况返回值同getopt函数 struct option 123456struct option &#123; const char *name; /* 参数名称 */ int has_arg; /* 指明是否带有参数 */ int *flag; /* flag=NULL时,返回value;不为空时,*flag=val,返回0 */ int val; /* 用于指定函数找到选项的返回值或flag非空时指定*flag的值*/&#125;; has_arg取值 123no_argument 表明长选项不带参数，如：--name, --helprequired_argument 表明长选项必须带参数，如：--prefix /root或 --prefix=/rootoptional_argument 表明长选项的参数是可选的，如：--help或 –prefix=/root，其它都是错误 下面通过实例代码演示用法 1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;getopt.h&gt;int main(int argc,char *argv[])&#123; int o,idx = 0; const char *short_opts = \"abc\"; struct option long_opts[] = &#123; &#123;\"help\",no_argument,NULL,'h'&#125;, &#123;\"ip\",optional_argument,NULL,'i'&#125;, &#123;\"port\",required_argument,NULL,'p'&#125;, &#123;NULL,0,NULL,0&#125; &#125;; while((o = getopt_long(argc,argv,short_opts,long_opts,&amp;idx)) != -1)&#123; printf(\"%c:%s\\t\",o,optarg); printf(\"optind=%d\\t\",optind); printf(\"next opt is %s\\n\",argv[optind]); &#125; return 0;&#125; 结果12345./app --help --port=8800 --ip=127.0.0.1h:(null) optind=2 next opt is --port=8800p:8800 optind=3 next opt is --ip=127.0.0.1i:127.0.0.1 optind=4 next opt is (null)","tags":[{"name":"Linux系统编程","slug":"Linux系统编程","permalink":"http://yoursite.com/tags/Linux系统编程/"}]},{"title":"MySQL查询学习笔记","date":"2018-11-05T13:18:22.000Z","path":"2018/11/05/MySQL查询学习笔记/","text":"数据的准备 创建一个数据库1create database data_test charset=utf8; 创建数据表 students表 123456789create table students( id int unsigned primary key auto_increment not null, name varchar(20) default '', age tinyint unsigned default 0, height decimal(5,2), gender enum('男','女','中性','保密') default '保密', cls_id int unsigned default 0, is_delete bit default 0 ); classes表 1234create table classes ( id int unsigned auto_increment primary key not null, name varchar(30) not null ); 准备数据 12345678910111213141516171819-- 向students表中插入数据insert into students values(0,'小明',18,180.00,2,1,0),(0,'小月月',18,180.00,2,2,1),(0,'彭于晏',29,185.00,1,1,0),(0,'刘德华',59,175.00,1,2,1),(0,'黄蓉',38,160.00,2,1,0),(0,'凤姐',28,150.00,4,2,1),(0,'王祖贤',18,172.00,2,1,1),(0,'周杰伦',36,NULL,1,1,0),(0,'程坤',27,181.00,1,2,0),(0,'刘亦菲',25,166.00,2,2,0),(0,'金星',33,162.00,3,3,1),(0,'静香',12,180.00,2,4,0),(0,'郭靖',12,170.00,1,4,0),(0,'周杰',34,176.00,2,5,0);-- 向classes表中插入数据insert into classes values (0, \"python_01期\"), (0, \"python_02期\"); 查询语句的使用查询所有字段 select * from 表名;1select * from students; 查询指定字段 select 列1,列2,… from 表名;1select name,age from students; 使用as给字段起别名 select 字段 as 名字 … from 表名; 1select name as 姓名,age as 年龄 from students; select 表名.字段 … from 表名 1select students.name,students.age from students; 可以通过as给表起别名 select 别名.字段 … from 表名 as 别名; 1selecct s.name,s.age from students as s; 消除重复行 distinct 字段1select distinct gender from students; 条件查询 比较运算符 select … from 表名 where …; 12345678--查询大于18岁的信息select * from students where age&gt;18;--查询小于18岁的信息select * from students where age&lt;18;--查询小于或者等于18岁的信息select * from students where age&lt;=18;--查询年龄为18岁的所有学生的信息select * from students where age=18; 逻辑运算符 and 1234--18到28之间的所有学生信息select * from students where age&gt;18 and age&lt;28;--18岁以上的女性select * from students where age&gt;18 and gender=\"女\"; or 12--18岁以上或者身高超过180以上select * from students where age&gt;18 or height&gt;180; not 1234--不在18岁以上的女性select * from students where not (age&gt;18 and gender=\"女\");--年龄不是小于或者等于18 并且是女性select * from students where (not age&lt;=18) and gender=\"女\"; 模糊查询 like %替换0个或者多个 _替换1个 12345678910--查询姓名中以 “小” 开始的名字select name from students where name like \"小%\";--查询姓名中有 “小” 所有名字select name from students where name like \"%小%\";--查询有两个字的名字select name from students where name like \"__\";--查询有三个字的名字select name from students where name like \"___\";--查询至少有两个字的名字select name from students where name like \"__%\"; rlike 正则表达式 1234--查询以“周”开始的姓名select name from students where name rlike \"^周.*\";--查询以“周”开始 “伦”结尾的姓名select name from students where name rlike \"^周.*伦$\"; 范围查询 in (1,3,8)表示在一个非连续的范围内 12--查询年龄为18，34的姓名select name,age from students where age in (18,34); not in 不在此非连续范围内 12--查询年龄不是18，34岁的名字select name,age from students where age not in (18,34); not between … and …表示不在一个连续的范围内 12--查询年龄不在18到34岁之间的信息select * from students where age not between 18 and 34; 空判断 is null 12--查询身高为空的信息select * from students where height is null; is not null 12--查询身高不为空的信息select * from students where height is not null; 排序 order by 字段 asc从小到大排序，即升序 desc从大到小排序，即降序1234--查询年龄在18到34岁之间的男性，按照年龄从小到大排序select * from students where age between 18 and 34 order by age asc;--按照年龄从小到大，身高从高到矮的排序select * from students order by age asc,height desc; 聚合函数 count 总数 123--查询男性有多少人，女性有多少人select count(*) from students where gender=\"男\";select count(*) from students where gender=\"女\"; max 最大值 12--查询最大年龄select max(age) from students; min 最小值 sum 求和 12--计算所有人的年龄总和select sum(age) from stundets; avg 平均值 12--计算平均年龄select avg(age) from students; round 四舍五入 round(123.12,1)保留一位小数123.1 12--计算所有人的平均年龄，保留2位小数select round(avg(age),2) from students; 分组 group by 123456--按照性别分组，查询所有的性别select gender from students group by gender;--计算每种性别的人数select gender,count(*) from students group by gender;--计算男性的人数select gender,count(*) from students where gender=\"男\" group by gender; group_concat(…) 12--查询同种性别中的姓名,年龄,身高select gender,group_concat(name,\",\",age,\",\",height) from students group by gender; having 1234--查询平均年龄超过30岁的性别，以及姓名select gender,group_concat(name) from students group by gender having avg(age)&gt;30;--查询每种性别中的人数多于2个的信息select gender,group_concat(name) from students group by gender having count(*)&gt;2; 分页 limit start,count12345678--限制查询出来的数据个数select * from students limit 5;--查询前5个数据select * from students limit 5;--查询id6-10的数据select * from students limit 5,5;--每页显示2个，显示第六页的信息，按照年龄从小到大排序select * from students order by age asc limit 10,2;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"MySQL基本操作","date":"2018-11-04T12:03:42.000Z","path":"2018/11/04/MySQL基本操作/","text":"数据库操作链接数据库 mysql -u用户名 -p密码 退出数据库 exit/quit/ctrl+d 显示数据库版本1select version(); 显示时间1selecct now(); 查看所有数据库1show databases; 创建数据库 create database 数据库名 (charset=utf-8);12create database mydatabase;create database mydatabase charset=utf-8; 查看创建数据库的语句 show create database 数据库名1show create database mydatabase; 查看当前使用的数据库1select database(); 使用数据库 use 数据库名1use mydatabase 删除数据库 drop database 数据库名1drop database mydatabase; 数据表的操作查看当前数据库中所有表1show tables; 创建表 create table 数据表名字([字段，类型，约束],…)123create table students(id int primary key auto_increment, name varchar(30) not null, age int); 查看表结构 desc 表名;1desc students; 查看表的创建语句 show create table 表名字;1show create table students; 修改表-添加字段 alter table 表名 add 列名 类型;1alter table students add birthday datetime; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束1alter table students modify birthday date; 修改表-修改字段：重命名版 alter table 表名 change 原名 新名 类型及约束;1alter table students change birthday birth date dafault \"2001-01-01\" 修改表-删除字段 alter table 表名 drop 列名;1alter table students drop age; 删除表 drop table 表名1drop table students; 数据库增删改查(curd)增加全列插入 insert into 表名 values(…);1insert into students values(0,\"小王\",\"1991-02-14\"); 部分插入 insert into 表名 (列1，…) values(列1值,…);1insert into students (name,birth) values(\"小张\",\"1993-12-22\"); 多行插入 insert into 表名 (列1，…) values(列1值,…),(列1值,…)…; insert into 表名 values(列1值,…),(列1值,…)…；12insert into students (name) values(\"小红\"),(\"小李\");insert into students values(default,\"大张\",default),(default,\"大王\",default); 修改 update 表名 set 列1=值1，列2=值2…where 条件;1update students set name=\"蜘蛛侠\",birth=\"2018-11-04\" where id=3; 查询基本使用查询所有列 select * from 表名1select * from students; 按条件查询 select * from 表名 where 条件;1select * from students where name=\"蜘蛛侠\"; 查询指定列 select 列1,列2,… from 表名;1select id,name from students; 查询定别名 select 字段 as 别名,字段 as 别名… from 表名;1select name as 姓名, birth as 生日 from students; 删除物理删除 delete from 表名 where 条件;12delete from students;delete from students where name=\"蜘蛛侠\"; 逻辑删除 使用一个字段来表示这条信息已经不能使用了，查询时候加上已经删除的不查询12alter table students add is_delete bit default 0;update students set is_delete=1 where id=6;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库基础-数据类型和约束","date":"2018-11-01T15:20:37.000Z","path":"2018/11/01/数据库基础-数据类型和约束/","text":"数据类型常见数据类型 整数:int,bit 小数:decimal 字符串:varchar,char 日期时间:date,time,datetime 枚举类型:enum特殊类型说明 decimal表示浮点数,如decimal(3,2)表示共存3位数,小数占2位 char表示固定长度的字符串,如char(3),如果填充’ab’时会补一个空格为’ab ‘ varchar表示变长的字符串,如varchar(3)，如果填充’ab’，实际就是’ab’ text类型存储大文本字符串,当字符大于4000时推荐使用 更全的数据类型可以参考这里 约束 主键primary key:物理上存储的顺序 非空not null:此字段不允许填写空置 唯一unique:此字段的值不允许重复 默认default:当不填写此值时会使用默认值，如果填写时以填写为准 外键foreign key:对关系字段进行约束,当为关系字段填写值时,会到关联的表中查询此值是否存在,如果存在则填写成功,如果不存在则填写失败并抛出异常 说明:虽然外键约束可以保证数据的有效性,但是在进行数据的crud(增加，修改，删除，查询)时，都会降低数据库的性能,所以不推荐使用,那么数据的有效性怎么保证呢？答:可以在逻辑层进行控制 数值类型归类(常用) 类型 字节大小 有符号范围(signed) 无符号范围(unsigned) TINYINT 1 -128~127 0~255 SMALLINT 2 -32768~32767 0~65535 MEDIUMINT 3 -8388608~8388607 0~16777215 INT/INTEGER 4 -2147483648~2147483647 0~4294967295 BITINT 8 -9223372036854775808~9223372036854775807 0~18446744073709551615 字符串 类型 字节大小 示例 CHAR 0~255 类型:char(3)输入’ab’,实际存储为’ab ‘,输入’abcd’ 实际存储为 ‘abc’ VARCHAR 0~255 类型:varchar(3) 输 ‘ab’,实际存储为’ab’, 输入’abcd’,实际存储为’abc’ TEXT 0~65535 大文本 日期时间类型 类型 字节大小 示例 DATE 4 ‘2018-11-01’ TIME 3 ‘0:08:00’ DATETIME 8 ‘2018-11-01 0:08:00’ YEAR 1 ‘2017’ TIMESTAMP 4 ‘1920-01-01 00:00:01’UTC~’2038-01-01 00:00:01’UTC","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"网络传输大小端问题","date":"2018-10-30T13:14:05.000Z","path":"2018/10/30/网络传输大小端问题/","text":"网络传输大小端问题我们在边写linux网络编程的时候经常会使用htonl htons等函数用来对int类型 long类型的数据进行本地字节序和网络字节序的转换，而对于字符串类型的数据，就不需要转换呢？ 网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?其实是按照传输数据的内存地址由低到高来进行传输的。 在验证上面这一个问题之前，先来看一下大小端的问题 小端字节序是我们比较常见的字节序，个人使用的x86计算机大部分使用小端字节序，其实很好理解,小端法(Little-Endian)就是低位字节排放在内存的低地址端(即该值的起始地址),高位字节排放在内存的高地址端; 大端法(Big-Endian)就是高位字节排放在内存的低地址端(即该值的起始地址),低位字节排放在内存的高地址端 就比如 0x12345678 这个十六进制数字，低位在最右边(理解一下十进制中12345678，从右往左是不是个十百千…)，小端存储法就是0x78在低地址，0x12在高地址;大端0x78在高地址，0x12在低地址，可以用下面这一段代码看看自己是不是小端字节序. 12345678#include &lt;stdio.h&gt;int main()&#123; int val = 0x12345678; char *pVal = (char*)&amp;val; printf(\"%x %x %x %x\\n\",*(pVal+0),*(pVal+1),*(pVal+2),*(pVal+3)); return 0;&#125; 输出结果是:78 56 34 12,证明了我使用的这台计算机是小端字节序 那么字符串在内存中存储形式是怎么样的呢？ 比如”Hello”这个字符串，在内存中则是按照字符串本身从左往右顺序存储，’H’在前，’o’在后。这个则没必要写代码来验证了，太简单… 有了以上基础知识,那么便可以说明第一个问题了 网络上传输数据是按内存地址从低到高按顺序传输,那么传输”Hello”这个字符串的时候，就是按照”H” “e” “l” “l” “o”的顺序依次传输，对方接收的话，也是按照这个顺序把数据存入缓存区,字符串不涉及到大小端存储的规则，所以无需调用字节序转换函数来处理。 如果是 0x12345678 这个数据，那么则是按照0x78 0x56 0x34 0x12这个顺序按字节发送(16进制2位则是一个字节),对方机器如果收到后用int类型来解释这个数据，如果对方机器是小端字节序，那么没问题，收到的数据还是0x12345678，但是如果对方机器是大端字节序,用int来解释则会把高地址数据放在低位 低地址放在高位，变成了0x78563412,就会发生不想要的结果。 结论 所以在字节序相同的平台时间传输数据，进行转换字节序是没必要的，而在不同平台之间，则一定要进行转换","tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"JDSpider使用文档","date":"2018-10-29T16:03:25.000Z","path":"2018/10/30/JDSpiderReadme/","text":"JDSpider介绍 JDSpider是一个Python写的京东抢券程序源码 配置文件使用Account.txt文件说明 这是账号cookies配置文件,必须按照指定格式配置 格式: 账号名—-这里随意填写—-cookies 12例如:18959273396----11----abtest=20181028143048053_24; mobilev=html5; sid=84964d12b0e88cf2e3545d93cb8d9925; Ticket.json文件说明 这是优惠券信息文件 格式如下12345678&#123; \"name\":\"东券非自营手机\", \"key\":\"ac496b99aa3b4fde8562ba3e14646cb2\", \"id\":\"15196163\", \"starttime\":\"2018-10-28 21:16:00.950\", 小数点后面为毫秒数 \"submitcnt\":\"3\", 提交次数 \"submitinterval\":\"200\" 提交间隔&#125; YDMConfig.json文件说明 云打码平台配置文件 格式如下123456&#123; \"username\":\"hn_user\", 云打码账号名 \"password\":\"xxxxxx\", 账号密码 \"appid\":6017, 开发者软件id \"appkey\":\"903e515dfee0a2bcabfd4a7f9a5d3daa\" 开发者软件秘钥&#125; 日志文件 抢券结束后在Log目录下会生成response_log.txt 和 result_log.txt文件 response_log.txt 记录了请求京东服务器对方给的回应 result_log.txt 记录了抢券结果，如果有账号成功领取到才会有记录","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]