[{"title":"MySQL基本操作","date":"2018-11-04T12:03:42.000Z","path":"2018/11/04/MySQL基本操作/","text":"数据库操作链接数据库 mysql -u用户名 -p密码 退出数据库 exit/quit/ctrl+d 显示数据库版本1select version(); 显示时间1selecct now(); 查看所有数据库1show databases; 创建数据库 create database 数据库名 (charset=utf-8);12create database mydatabase;create database mydatabase charset=utf-8; 查看创建数据库的语句 show create database 数据库名1show create database mydatabase; 查看当前使用的数据库1select database(); 使用数据库 use 数据库名1use mydatabase 删除数据库 drop database 数据库名1drop database mydatabase; 数据表的操作查看当前数据库中所有表1show tables; 创建表 create table 数据表名字([字段，类型，约束],…)123create table students(id int primary key auto_increment, name varchar(30) not null, age int); 查看表结构 desc 表名;1desc students; 查看表的创建语句 show create table 表名字;1show create table students; 修改表-添加字段 alter table 表名 add 列名 类型;1alter table students add birthday datetime; 修改表-修改字段：不重命名版 alter table 表名 modify 列名 类型及约束1alter table students modify birthday date; 修改表-修改字段：重命名版 alter table 表名 change 原名 新名 类型及约束;1alter table students change birthday birth date dafault \"2001-01-01\" 修改表-删除字段 alter table 表名 drop 列名;1alter table students drop age; 删除表 drop table 表名1drop table students; 数据库增删改查(curd)增加全列插入 insert into 表名 values(…);1insert into students values(0,\"小王\",\"1991-02-14\"); 部分插入 insert into 表名 (列1，…) values(列1值,…);1insert into students (name,birth) values(\"小张\",\"1993-12-22\"); 多行插入 insert into 表名 (列1，…) values(列1值,…),(列1值,…)…; insert into 表名 values(列1值,…),(列1值,…)…；12insert into students (name) values(\"小红\"),(\"小李\");insert into students values(default,\"大张\",default),(default,\"大王\",default); 修改 update 表名 set 列1=值1，列2=值2…where 条件;1update students set name=\"蜘蛛侠\",birth=\"2018-11-04\" where id=3; 查询基本使用查询所有列 select * from 表名1select * from students; 按条件查询 select * from 表名 where 条件;1select * from students where name=\"蜘蛛侠\"; 查询指定列 select 列1,列2,… from 表名;1select id,name from students; 查询定别名 select 字段 as 别名,字段 as 别名… from 表名;1select name as 姓名, birth as 生日 from students; 删除物理删除 delete from 表名 where 条件;12delete from students;delete from students where name=\"蜘蛛侠\"; 逻辑删除 使用一个字段来表示这条信息已经不能使用了，查询时候加上已经删除的不查询12alter table students add is_delete bit default 0;update students set is_delete=1 where id=6;","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"数据库基础-数据类型和约束","date":"2018-11-01T15:20:37.000Z","path":"2018/11/01/数据库基础-数据类型和约束/","text":"数据类型常见数据类型 整数:int,bit 小数:decimal 字符串:varchar,char 日期时间:date,time,datetime 枚举类型:enum特殊类型说明 decimal表示浮点数,如decimal(3,2)表示共存3位数,小数占2位 char表示固定长度的字符串,如char(3),如果填充’ab’时会补一个空格为’ab ‘ varchar表示变长的字符串,如varchar(3)，如果填充’ab’，实际就是’ab’ text类型存储大文本字符串,当字符大于4000时推荐使用 更全的数据类型可以参考这里 约束 主键primary key:物理上存储的顺序 非空not null:此字段不允许填写空置 唯一unique:此字段的值不允许重复 默认default:当不填写此值时会使用默认值，如果填写时以填写为准 外键foreign key:对关系字段进行约束,当为关系字段填写值时,会到关联的表中查询此值是否存在,如果存在则填写成功,如果不存在则填写失败并抛出异常 说明:虽然外键约束可以保证数据的有效性,但是在进行数据的crud(增加，修改，删除，查询)时，都会降低数据库的性能,所以不推荐使用,那么数据的有效性怎么保证呢？答:可以在逻辑层进行控制 数值类型归类(常用) 类型 字节大小 有符号范围(signed) 无符号范围(unsigned) TINYINT 1 -128~127 0~255 SMALLINT 2 -32768~32767 0~65535 MEDIUMINT 3 -8388608~8388607 0~16777215 INT/INTEGER 4 -2147483648~2147483647 0~4294967295 BITINT 8 -9223372036854775808~9223372036854775807 0~18446744073709551615 字符串 类型 字节大小 示例 CHAR 0~255 类型:char(3)输入’ab’,实际存储为’ab ‘,输入’abcd’ 实际存储为 ‘abc’ VARCHAR 0~255 类型:varchar(3) 输 ‘ab’,实际存储为’ab’, 输入’abcd’,实际存储为’abc’ TEXT 0~65535 大文本 日期时间类型 类型 字节大小 示例 DATE 4 ‘2018-11-01’ TIME 3 ‘0:08:00’ DATETIME 8 ‘2018-11-01 0:08:00’ YEAR 1 ‘2017’ TIMESTAMP 4 ‘1920-01-01 00:00:01’UTC~’2038-01-01 00:00:01’UTC","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"网络传输大小端问题","date":"2018-10-30T13:14:05.000Z","path":"2018/10/30/网络传输大小端问题/","text":"网络传输大小端问题我们在边写linux网络编程的时候经常会使用htonl htons等函数用来对int类型 long类型的数据进行本地字节序和网络字节序的转换，而对于字符串类型的数据，就不需要转换呢？ 网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?其实是按照传输数据的内存地址由低到高来进行传输的。 在验证上面这一个问题之前，先来看一下大小端的问题 小端字节序是我们比较常见的字节序，个人使用的x86计算机大部分使用小端字节序，其实很好理解,小端法(Little-Endian)就是低位字节排放在内存的低地址端(即该值的起始地址),高位字节排放在内存的高地址端; 大端法(Big-Endian)就是高位字节排放在内存的低地址端(即该值的起始地址),低位字节排放在内存的高地址端 就比如 0x12345678 这个十六进制数字，低位在最右边(理解一下十进制中12345678，从右往左是不是个十百千…)，小端存储法就是0x78在低地址，0x12在高地址;大端0x78在高地址，0x12在低地址，可以用下面这一段代码看看自己是不是小端字节序. 12345678#include &lt;stdio.h&gt;int main()&#123; int val = 0x12345678; char *pVal = (char*)&amp;val; printf(\"%x %x %x %x\\n\",*(pVal+0),*(pVal+1),*(pVal+2),*(pVal+3)); return 0;&#125; 输出结果是:78 56 34 12,证明了我使用的这台计算机是小端字节序 那么字符串在内存中存储形式是怎么样的呢？ 比如”Hello”这个字符串，在内存中则是按照字符串本身从左往右顺序存储，’H’在前，’o’在后。这个则没必要写代码来验证了，太简单… 有了以上基础知识,那么便可以说明第一个问题了 网络上传输数据是按内存地址从低到高按顺序传输,那么传输”Hello”这个字符串的时候，就是按照”H” “e” “l” “l” “o”的顺序依次传输，对方接收的话，也是按照这个顺序把数据存入缓存区,字符串不涉及到大小端存储的规则，所以无需调用字节序转换函数来处理。 如果是 0x12345678 这个数据，那么则是按照0x78 0x56 0x34 0x12这个顺序按字节发送(16进制2位则是一个字节),对方机器如果收到后用int类型来解释这个数据，如果对方机器是小端字节序，那么没问题，收到的数据还是0x12345678，但是如果对方机器是大端字节序,用int来解释则会把高地址数据放在低位 低地址放在高位，变成了0x78563412,就会发生不想要的结果。 结论 所以在字节序相同的平台时间传输数据，进行转换字节序是没必要的，而在不同平台之间，则一定要进行转换","tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"JDSpider使用文档","date":"2018-10-29T16:03:25.000Z","path":"2018/10/30/JDSpiderReadme/","text":"JDSpider介绍 JDSpider是一个Python写的京东抢券程序源码 配置文件使用Account.txt文件说明 这是账号cookies配置文件,必须按照指定格式配置 格式: 账号名—-这里随意填写—-cookies 12例如:18959273396----11----abtest=20181028143048053_24; mobilev=html5; sid=84964d12b0e88cf2e3545d93cb8d9925; Ticket.json文件说明 这是优惠券信息文件 格式如下12345678&#123; \"name\":\"东券非自营手机\", \"key\":\"ac496b99aa3b4fde8562ba3e14646cb2\", \"id\":\"15196163\", \"starttime\":\"2018-10-28 21:16:00.950\", 小数点后面为毫秒数 \"submitcnt\":\"3\", 提交次数 \"submitinterval\":\"200\" 提交间隔&#125; YDMConfig.json文件说明 云打码平台配置文件 格式如下123456&#123; \"username\":\"hn_user\", 云打码账号名 \"password\":\"xxxxxx\", 账号密码 \"appid\":6017, 开发者软件id \"appkey\":\"903e515dfee0a2bcabfd4a7f9a5d3daa\" 开发者软件秘钥&#125; 日志文件 抢券结束后在Log目录下会生成response_log.txt 和 result_log.txt文件 response_log.txt 记录了请求京东服务器对方给的回应 result_log.txt 记录了抢券结果，如果有账号成功领取到才会有记录","tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]}]